---
title: LeetCode 100 - 200
date: 2018-02-10 04:19:13
tags: 
categories:
---

##### 101. Symmetric Tree

Given a binary tree, check whether it is a mirror of itself (ie, symmetric around its center).

For example, this binary tree [1,2,2,3,4,4,3] is symmetric:
```java
class Solution {
    public boolean isSymmetric(TreeNode root) {
        if (root == null) {
            return true;
        }
        return isSymmetric(root.left, root.right);
    }
    public boolean isSymmetric(TreeNode left, TreeNode right) {
        if (left == null && right == null) {
            return true;
        }
        if (left == null || right == null) {
            return false;
        }
        if (left.val != right.val) {
            return false;
        }
        return isSymmetric(left.left, right.right) && isSymmetric(left.right, right.left);
    } 
}
//**very important** -- iterative
// when the left and right both equal to null, we can not just return true like what we did for recursion.
//because recursion only return to the sub result, but when we do it iteratively, we can only return the final result, 
so, if both left and right are null, we still have to conitnue to check rest of the nodes.
class Solution {
    public boolean isSymmetric(TreeNode root) {
        if (root == null) {
            return true;
        }
        Queue<TreeNode> queue = new LinkedList<>();
        queue.offer(root.left);
        queue.offer(root.right);
        while (!queue.isEmpty()) {
            TreeNode left  = queue.poll();
            TreeNode right = queue.poll();
            if (left == null && right == null) {
                continue;
            }
            if (left == null || right == null || left.val != right.val) {
                return false;
            }
            queue.offer(left.left);
            queue.offer(right.right);
            queue.offer(left.right);
            queue.offer(right.left);
        }
        return true;
    }
}
```
##### 104. Maximum Depth of Binary Tree

Given a binary tree, find its maximum depth.

The maximum depth is the number of nodes along the longest path from the root node down to the farthest leaf node.
```java
/*
(iterative approach)
level traverse, the last level has node, will be the answer
 */
class Solution {
    public int maxDepth(TreeNode root) {
        if (root == null) {
            return 0;
        }
        return Math.max(maxDepth(root.left), maxDepth(root.right)) + 1;
    }
}
```
105. Construct Binary Tree from Preorder and Inorder Traversal

Given preorder and inorder traversal of a tree, construct the binary tree.
Note:
You may assume that duplicates do not exist in the tree.
```java
/* time O(n *n) as every time we have to find the root in the inorder array,
but we use a map to reduce the run time to O(n), and use O(n) space
*** if there are no duplicates nodes

idea: preorder: root is always the first, inorder: it is in ascending order
based on this, we can locate the root in the inorder array,
elements in the left side are belong to the left tree, same logic for the right side
as we know the number of elements of the left tree, 
we can also know the range for the left tree or right tree
**important point** for the left tree, the preStart will always be the next element,
but for the right tree, the preStart will be preStart - (number of left tree nodes) + 1
and, for the helper function, the exit condition will be instart > inend, 
and no need to check if prestart ever go beyond the array length, 
the instart and inend will cover the range
 */
class Solution {
    public TreeNode buildTree(int[] preorder, int[] inorder) {
        if (preorder == null || inorder == null || preorder.length != inorder.length) {
            return null;
        }
        Map<Integer, Integer> map = new HashMap<>();
        for (int i = 0; i < inorder.length; ++i) {
            map.put(inorder[i], i);
        }
        return buildTreeHelper(map, preorder, inorder, 0, 0, inorder.length - 1);
    }
    public TreeNode buildTreeHelper(Map<Integer, Integer> map, int[] pre, int[] in, 
                                    int prestart, int instart, int inend) {
        if (instart > inend) {
            return null;
        }
        TreeNode root = new TreeNode(pre[prestart]);
        int inroot = map.get(pre[prestart]);
        int secondPrestart = prestart + (inroot - instart) + 1;
        root.left = buildTreeHelper(map, pre, in, prestart + 1, instart, inroot - 1);
        root.right = buildTreeHelper(map, pre, in, secondPrestart, inroot + 1, inend);
        return root;
    }
}
```
106. Construct Binary Tree from Inorder and Postorder Traversal

Given inorder and postorder traversal of a tree, construct the binary tree.
Note:
You may assume that duplicates do not exist in the tree.
```java
/* draw a tree and all the traversals to see the pattern 
the idea is for the postorder, the root is always the last follow by the right subtree
for the inorder, it is in ascending order
based on this, we can locate the root in the inorder array, the elements in the left side are belong to the left tree
as we know the number of elements of the left tree, we will know the range for the left or right tree
**important point** for the right tree, the postEnd will always be the pre element,
but for the left tree, the postEnd will be postStart - (number of right tree nodes) - 1
and, for the helper function, the exit condition will be instart > inend, and we do not need to check if postStart 
ever go beyond 0, because the instart and inend will cover the range
 */
class Solution {
    public TreeNode buildTree(int[] inorder, int[] postorder) {
        if (inorder == null || postorder == null || inorder.length != postorder.length) {
            return null;
        }
        return buildTree(inorder, postorder, 0, inorder.length - 1, inorder.length - 1);
    }
    public TreeNode buildTree(int[] in, int[] post, int inStart, int inEnd, int postEnd) {
        if (inStart > inEnd) {
            return null;
        }
        int rootIn = inStart;
        for (; rootIn <= inEnd && in[rootIn] != post[postEnd]; ++rootIn);
        TreeNode root = new TreeNode(post[postEnd]);
        root.right = buildTree(in, post, rootIn + 1, inEnd, postEnd - 1);
        root.left  = buildTree(in, post, inStart, rootIn - 1, postEnd - (inEnd - rootIn) - 1);
        return root;
    }
}
```
108. Convert Sorted Array to Binary Search Tree

Given an array where elements are sorted in ascending order, convert it to a height balanced BST.

For this problem, a height-balanced binary tree is defined as a binary tree in which the depth of the two subtrees of every node never differ by more than 1.
```java
/* time O(n)
recursionly use the middle of the array as root, left side of the array be the left tree
 */
class Solution {
    public TreeNode sortedArrayToBST(int[] nums) {
        return nums == null ? null : buildBST(nums, 0, nums.length - 1);
    }
    public TreeNode buildBST(int[] nums, int start, int end) {
        if (start > end) {
            return null;
        }
        int mid = (end - start) / 2 + start;
        TreeNode root = new TreeNode(nums[mid]);
        root.left = buildBST(nums, start, mid - 1);
        root.right = buildBST(nums, mid + 1, end);
        return root;
    }
}class LRUCache {
    /**
     * 思路，需要经常删除，添加，移动data，array 或者arraylist首先可以排除了 queue和stack 类似
     * 而且需要保持添加顺序，hashmap 和hashset 也可以排除了，
     * 所以，最好的数据结构应该就是 链表
     * 但链表的问题就是，无法很快的定位到目标元素，所以可以配合一个hashmap来记录位置，然后删除节点的时候，
     * 但java中的linkedlist 在只知道目标节点的位置 是无法删除该 节点的，
     * 总结来说，这题应该只能自己实现一个双向链表, 内置一个头结点，一个尾节点，一个前指针一个后指针
     *
     * put函数
     * 1. key已经在list中，只是更新value，
     * 2. key不在list中，新建节点， 这时候就要把新节点加到链表前面，然后查看capacity是否越界，越界的话，删除最后一个节点
     *
     * get
     * 1. key不在list中，返回 -1
     * 2. key在list中，要把该节点move到最前面，也可以新建一个节点放前面然后，删除原节点
     *
     * 所以可以用2个helper 函数
     * 1. moveToHead
     * 2. removeNode
     * 
     * 需要注意的点，当size超过capacity的时候，除了要remove尾节点，还要把该节点的映射从map里面删掉，同时--size
     * */
    class Node{
        Node prev;
        Node next;
        int key;
        int value;
        private Node(int key, int value) {
            this.key = key;
            this.value = value;
        }
    }
    private int capacity;
    private int size;
    private Node head;
    private Node tail;
    private Map<Integer, Node> map;
    public LRUCache(int capacity) {
        this.capacity = capacity;
        map = new HashMap<>();
        head = new Node(0, 0);
        tail = new Node(0, 0);
        head.next = tail;
        tail.prev = head;
        size = 0;
    }

    public int get(int key) {
        if (!map.containsKey(key)) {
            return -1;
        }
        Node node = map.get(key);
        removeNode(node);
        moveToHead(node);
        return node.value;
    }

    public void put(int key, int value) {
        if (map.containsKey(key)) {
            Node node = map.get(key);
            node.value = value;
            removeNode(node);
            moveToHead(node);
        } else {
            Node node = new Node(key, value);
            moveToHead(node);
            map.put(key, node);
            if (++size > capacity) {
                Node last = tail.prev;
                removeNode(last);
                map.remove(last.key);
                --size;
            }
        }
    }
    private void moveToHead(Node node) {
        Node oldHead = head.next;
        head.next = node;
        node.prev = head;
        node.next = oldHead;
        oldHead.prev = node;
    }
    private void removeNode(Node node) {
        node.prev.next = node.next;
        node.next.prev = node.prev;
        /**
            following commented code are not necessary, but good to have,
            because after remove the node, there are two cases
            1. we do not need the node any more, it will go to the GC
            2. we do need to move it to the head, and we will update its prev and next pointer anyway
        */
        // node.prev = null;
        // node.next = null;
    }
}

/**
 * Your LRUCache object will be instantiated and called as such:
 * LRUCache obj = new LRUCache(capacity);
 * int param_1 = obj.get(key);
 * obj.put(key,value);
 */
109. Convert Sorted List to Binary Search Tree

Given a singly linked list where elements are sorted in ascending order, convert it to a height balanced BST.

For this problem, a height-balanced binary tree is defined as a binary tree in which the depth of the two subtrees of every node never differ by more than 1.
```java
/** 
time O(nlogn) space O(logn) 每次找中点需要2/n时间，一共有logn（次）层递归
思路：用快慢指针找到中点，然后把中点设为root，左边递归建左子树，右边右子树，递归函数需要传入head和tail2个node
这样，找中点的时候就知道从哪里结束了。左边的tail就是上次的root，右边的tail就是本来右边的tail（null）
2.0
the idea is two pointer slow and fast to find the midium of the list, then use the midium as the current root, 
then the left half of the left will be the left subtree, and same logic for right side
in order to not change the original structure of the give list, we can use a helper function 
1.0
*important* use head and tail to pointer to find the mid point of the first and second half of the list,
the tail will be the current root of the first half, and null for the second half,
so every time, the root is a root that we have already used or it is null, we know we have done.
unlike a array, we can easily find the mid point, 
but we can still use slow and fast two pointer to locate to the middle point
we can dived the list into three ways, head to slow, slow, slow.next to null;
as in the first part, we already use slow as the root, we will return null if we see that node again.
 */
class Solution {
    public TreeNode sortedListToBST(ListNode head) {
        return head == null ? null : sortedListToBST(head, null);
    }
    public TreeNode sortedListToBST(ListNode head, ListNode tail) {
        if (head == tail) {
            return null;
        }
        ListNode slow = head;
        ListNode fast = head;
        while (fast != tail && fast.next != tail) {
            slow = slow.next;
            fast = fast.next.next;
        }
        TreeNode root = new TreeNode(slow.val);
        root.left  = sortedListToBST(head, slow);
        root.right = sortedListToBST(slow.next, tail);
        return root;
    }
}
```
110. Balanced Binary Tree

Given a binary tree, determine if it is height-balanced.

For this problem, a height-balanced binary tree is defined as a binary tree in which the depth of the two subtrees of every node never differ by more than 1.
```java
/* the idea is use getHeightHelper function to check all the heights for left subtrees and right subtrees
the height of the root will be Math.max(left, right) + 1;
as we can only return the one data type, so we can make the unbalanced tree as  -1
so, if the difference between left and right is greater than 1, we can mark that subtree as -1
then if any of the left or right subtree is already an unbalanced tree, the root must be an unbalanced tree as well
 */
class Solution {
    public boolean isBalanced(TreeNode root) {
        return getHeight(root) != -1;
    }
    public int getHeight(TreeNode root) {
        if (root == null) {
            return 0;
        }
        int left = getHeight(root.left);
        int right = getHeight(root.right);
        if (left == -1 || right == -1 || Math.abs(left - right) > 1) {
            return -1;
        }
        return Math.max(left, right) + 1;
    }
}
```
111. Minimum Depth of Binary Tree

Given a binary tree, find its minimum depth.

The minimum depth is the number of nodes along the shortest path from the root node down to the nearest leaf node.
```java
/* 
## iteratively: the idea is use level traversal
the level with the first node do not have left and right node will be the shortest level
## recursionly: key point is root A with left B with right null, return 2. 
means the node must do not have left and right, even it is the root, 
must check if the left is null then check right
based on this idea 
if the root is null, then return 0,
if left and right both null, return 1
if left and right both not null, return min(left, right) + 1
if only left is null, then right + 1
else (if only right i snull) then return left + 1
 */
class Solution {
    public int minDepth(TreeNode root) {
        if (root == null) {
            return 0;
        }
        if (root.left == null && root.right == null) {
            return 1;
        }
        if (root.left != null && root.right != null) {
            return 1 + Math.min(minDepth(root.left), minDepth(root.right));
        }
        return root.left == null ? 1 + minDepth(root.right) : 1 + minDepth(root.left);
    }
}
//iterative
class Solution {
    public int minDepth(TreeNode root) {
        if (root == null ){
            return 0;
        }
        int min = 1;
        Deque<TreeNode> queue = new ArrayDeque<>();
        queue.offer(root);
        while (!queue.isEmpty()) {
            int size = queue.size();
            while (--size >= 0) {
                TreeNode curr = queue.poll();
                if (curr.left == null && curr.right == null) {
                    return min;
                }
                if (curr.left != null) {
                    queue.offer(curr.left);
                }
                if (curr.right != null) {
                    queue.offer(curr.right);
                }
            }
            ++min;
        }
        return min;
    }
}
```
112. Path Sum

Given a binary tree and a sum, determine if the tree has a root-to-leaf path such that adding up all the values along the path equals the given sum.

```java
/* this is wrong, because if the root is null and sum is 0, it will return true;
if (root == null) return sum == 0;
return hasPathSum(root.left, sum - root.val) || hasPathSum(root.right, sum - root.val);

idea: from the root, finding a sum n path, means we are looking for from left or right node, a sum n - root.val path
 */
class Solution {
    public boolean hasPathSum(TreeNode root, int sum) {
        if (root == null) {
            return false;
        }
        if (root.left == null && root.right == null) {
            return root.val == sum;
        }
        return hasPathSum(root.left, sum - root.val) || hasPathSum(root.right, sum - root.val);
    }
}
```
113. Path Sum II

Given a binary tree and a sum, find all root-to-leaf paths where each path's sum equals the given sum.
```java
/*
recursion: **important things**
1. if the root is null then return;
2. add the root.val to the sub result first before add subresult to result otherwise, will lose the leaf
3. after add subresult to result and call the helper function, we must backtrack
alternative way for step 3, do not backtrack after add subresult to result, also do not return (meas conitue the rest code)

iteratively
need three stacks, one for the node, one for the total, one for the path
 */
class Solution {
    public List<List<Integer>> pathSum(TreeNode root, int sum) {
        List<List<Integer>> res = new ArrayList<List<Integer>>();
        pathSumHelper(root, sum, res, new ArrayList<>());
        return res;
    }
    public void pathSumHelper(TreeNode root, int sum, List<List<Integer>> res, List<Integer> curr) {
        if (root == null) { 
            return;
        }
        curr.add(root.val);
        if (root.left == null && root.right == null && sum == root.val) {
            res.add(new ArrayList<>(curr));
            //delete the following two lines also works
            curr.remove(curr.size() - 1);
            return;
        }
        pathSumHelper(root.left, sum - root.val, res, curr);
        pathSumHelper(root.right, sum - root.val, res, curr);
        curr.remove(curr.size() - 1);
    }
}

//iteratively

class Solution {
    public List<List<Integer>> pathSum(TreeNode root, int sum) {
        List<List<Integer>> res = new ArrayList<List<Integer>>();
        if (root == null) {
            return res;
        } 
        List<Integer> ls = new ArrayList<>();
        Stack<TreeNode> node = new Stack<>();
        Stack<Integer> total = new Stack<>();
        Stack<List<Integer>> path = new Stack<>();
        node.push(root);
        total.push(root.val);
        ls.add(root.val);
        path.push(ls);
        while (!node.empty()) {
            TreeNode head = node.pop();
            int curr = total.pop();
            List<Integer> path_left = path.pop();
            List<Integer> path_right = new ArrayList<>(path_left);
            if (head.left == null && head.right == null && curr == sum) {
                res.add(path_left);
            }
            if (head.left != null) {
                node.push(head.left);
                total.push(head.left.val + curr);
                path_left.add(head.left.val);
                path.push(path_left);
            }
            if (head.right != null) {
                node.push(head.right);
                total.push(head.right.val + curr);
                path_right.add(head.right.val);
                path.push(path_right);
            }
        }
        return res;
    }
}
```
114. Flatten Binary Tree to Linked List
![Capture-1](/content/images/2018/01/Capture-1.PNG)
Given a binary tree, flatten it to a linked list in-place.
```java
/*
idea is if there is no left node, we can just simple continue to do the right node,
if there is a left node, we have to put the right node after the most right of the left node, 
then use the right pointer point to the left node, clear the left pointer, then repeat the process
 */
class Solution {
    public void flatten(TreeNode root) {
        if (root == null || root.left == null && root.right == null) {
            return;
        }
        TreeNode head = root;
        while (head != null) {
            TreeNode left = head.left;
            TreeNode right = head.right;
            if (left == null && right == null) {
                return;
            } else if (right == null) {
                head.right = left;
                head.left  = null;
                head = head.right;
            } else if (left == null) {
                head = head.right;
            } else {
                TreeNode tem = left;
                while (tem.right != null) {
                    tem = tem.right;
                }
                tem.right  = right;
                head.right = left;
                head.left  = null;
                head = head.right;
            }
        }      
    }
}
```
115. Distinct Subsequences

Given a string S and a string T, count the number of distinct subsequences of S which equals T.

A subsequence of a string is a new string which is formed from the original string by deleting some (can be none) of the characters without disturbing the relative positions of the remaining characters. (ie, "ACE" is a subsequence of "ABCDE" while "AEC" is not).

Here is an example:
S = "rabbbit", T = "rabbit"

Return 3.
```java
/*BB面经
if the length of the string is very very large we have to use tries to solve this
https://www.geeksforgeeks.org/count-distinct-substrings-string-using-suffix-trie/
*/
/* the idea is use dp, 这个例子很重要
this can be optimize to 1D array
    b b b
  1 1 1 1
b 0 1 2 3
b 0 0 1 3
重点： 如果字符不一样，现在的结果完全取决于 没有char s时候的结果，
      但如果字符一样，那么当前结果就是 没有char s时候的结果 加上 char s 和char t 都没有时候的结果
inital state: if the T is empty, then for every letter in S, there is one subsequence
function: 1. if char s != char t, dp[i][j] should = dp[i][j-1]
if they are different, current result is baesd on the result without current char s
          2. if char s == char t, dp[i][j] should = dp[i][j-1] + dp[i-1][j-1]
if they are same, result is baesd on the result without char s and result without both char s and char t,
*/
class Solution {
    public int numDistinct(String s, String t) {
        if (s == null || t == null || s.length()  < t.length()) {
            return 0;
        }
        int sl = s.length();
        int tl = t.length();
        int[][] dp = new int[tl + 1][sl + 1];
        for (int i = 0; i <= sl; ++i) {
            dp[0][i] = 1;
        }
        for (int i = 1; i <= tl; ++i) {
            for  (int j = 1; j <= sl; ++j) {
                if (t.charAt(i - 1) != s.charAt(j - 1)) {
                    dp[i][j] = dp[i][j - 1];
                } else {
                    dp[i][j] = dp[i][j - 1] + dp[i - 1][j - 1];
                }
            }
        }
        return dp[tl][sl];
    }
}
```
116. Populating Next Right Pointers in Each Node

`this qustion is for a perfect tree, but the solution is for any kind of binary tree`


Given a binary tree

struct TreeLinkNode {
  TreeLinkNode *left;
  TreeLinkNode *right;
  TreeLinkNode *next;
}
Populate each next pointer to point to its next right node. If there is no next right node, the next pointer should be set to NULL.

Initially, all next pointers are set to NULL.

Note:

You may only use constant extra space.
You may assume that it is a perfect binary tree (ie, all leaves are at the same level, and every parent has two children).
For example,
![Screen-Shot-2017-12-28-at-3.13.50-PM](/content/images/2017/12/Screen-Shot-2017-12-28-at-3.13.50-PM.png)
```java
/*time O(n)
idea is use a dummy node traversal only to right to connect all nodes in that level 
1. create a dummy node, and curr point to dummy,
if there is a head.left, curr.next head.left, update curr to next, same for right
then move the head to next, to connect all the node for this level
if there is no more node in this level, head = dummy.next to go to the next level
 */
public class Solution {
    public void connect(TreeLinkNode root) {
        if (root == null || root.left == null && root.right == null) {
            return;
        }
        TreeLinkNode head = root;
        while (head != null) {
            TreeLinkNode dummy = new TreeLinkNode(0);
            TreeLinkNode curr = dummy;
            while (head != null) {
                if (head.left != null) {
                    curr.next = head.left;
                    curr = curr.next;
                }
                if (head.right != null) {
                    curr.next = head.right;
                    curr = curr.next;
                }
                head = head.next;
            }
            head = dummy.next;
        }
    }
}
```
118. Pascal's Triangle

Given numRows, generate the first numRows of Pascal's triangle.

For example, given numRows = 5,
Return
     [1],
    [1,1],
   [1,2,1],
  [1,3,3,1],
 [1,4,6,4,1]
```java
/* one idea is use 2D array
initial the first element to 1, after the first element, the current element will be the upper plus upper left,
then stop when the last element is equels to the level number
**important !!** 
1. when initialize a 2D array, it is optional to initial the column size
2. when convert a 2D array to a 2D list, the snytax is (List)Arrays.asList(array);

BUT, this question can be solve without using extra space, and it will be the same idea.
**/
class Solution {
    public List<List<Integer>> generate(int numRows) {
        List<List<Integer>> res = new ArrayList<List<Integer>>();
        List<Integer> tem = new ArrayList<>();
        tem.add(1);
        for (int level = 0; level < numRows; ++level) {
            res.add(new ArrayList<>(tem));
            for (int i = 1; i < level + 1; ++i) {
                if (i == level) {
                    res.get(level).add(1);
                } else {
                    res.get(level).add(res.get(level - 1).get(i) + res.get(level - 1).get(i - 1));
                }
            }
        }
        return res;
    }
}
```
119. Pascal's Triangle II

Given an index k, return the kth row of the Pascal's triangle.

For example, given k = 3,
Return [1,3,3,1].

Note:
Could you optimize your algorithm to use only O(k) extra space?
```java
/*
as we are only allowed to use k extra space, means we can only use 1D array to store 1 level result
but, as we need the data at postion(i - 1), using 1D will override the data
**important** the idea is add from back to front
*/
class Solution {
    public List<Integer> getRow(int rowIndex) {
        if (rowIndex < 0) {
            return new ArrayList<>(); 
        }
        Integer[] res = new Integer[rowIndex + 1]; 
        for (int level = 0; level <= rowIndex; ++level) { 
            for (int i = level; i >= 0; --i) {
                if (i == level || i == 0) {
                    res[i] = 1;
                } else {
                    res[i] += res[i - 1];
                }
            }
        }
        return Arrays.asList(res);
    }
}
```
120. Triangle

Given a triangle, find the minimum path sum from top to bottom. Each step you may move to adjacent numbers on the row below.
![120](/content/images/2018/01/120.PNG)
```java
/*
idea is for each element, the min will be itselt + the smaller number between(bottom, and bottom right),
but if we do it top - down, the furture data will be override
**important**, so we have to do it bottom - up
*/
class Solution {
    public int minimumTotal(List<List<Integer>> triangle) {
        if (triangle == null || triangle.size() == 0) {
            return -1;
        }
        int[] lastRow = new int[triangle.size()];
        for (int i = 0; i < triangle.size(); ++i) {
            lastRow[i] = triangle.get(triangle.size() - 1).get(i);
        }
        for (int i = triangle.size() - 2; i >= 0; --i) {
            for (int j = 0; j <= i; ++j) {
                lastRow[j] = triangle.get(i).get(j) + Math.min(lastRow[j], lastRow[j + 1]);
            }
        }
        return lastRow[0];
    }
}
```
121. Best Time to Buy and Sell Stock

Say you have an array for which the ith element is the price of a given stock on day i.

If you were only permitted to complete at most one transaction (ie, buy one and sell one share of the stock), design an algorithm to find the maximum profit.
```java
/*
the idea is use two pointer, (buy point and sell point), keep moving the sell point,
calculate the profit every time, update if found a larger profit,
update the buy point if found a lower price
*/
class Solution {
    public int maxProfit(int[] prices) {
        if (prices == null || prices.length < 2) {
            return 0;
        }
        int max = 0;
        for (int buy = 0, sell = 1; sell < prices.length; ++sell) {
            if (prices[sell] < prices[buy]) {
                buy = sell;
            } else {
                max = Math.max(max, prices[sell] - prices[buy]);
            }   
        }
        return max;
    }
}
```
122. Best Time to Buy and Sell Stock II

Say you have an array for which the ith element is the price of a given stock on day i.

Design an algorithm to find the maximum profit. You may complete as many transactions as you like (ie, buy one and sell one share of the stock multiple times). However, you may not engage in multiple transactions at the same time (ie, you must sell the stock before you buy again).


```java
/**
idea is if the current price is higher than the previous price, we will just keep updating the currMax,
until the curr price is lower than pre price, we can add the currMax to max, then start a new buy point
**important**
1. if we only return max, we may lose the last profit we made if we did not get a lower price
so, we have to return the max plus the currentMax,
2. we also need to reset the currentMax to 0, when we find a lower price,
otherwise, we will add the currentMax twice.

**/
class Solution {
    public int maxProfit(int[] prices) {
        if (prices == null || prices.length < 2) {
            return 0;
        }
        int max = 0;
        int buy = 0;
        for (int sell = 1; sell < prices.length; ++sell) {
            if (prices[sell] <= prices[sell - 1]) {
                max += prices[sell - 1] - prices[buy];
                buy = sell;
            }
            if (prices[sell] > prices[sell - 1]) {
                //do nothing
            } 
        }
        return max + prices[prices.length - 1] - prices[buy];
        //return max + currMax;
    }
}
class Solution {
    public int maxProfit(int[] prices) {
        if (prices == null || prices.length < 2) {
            return 0;
        }
        int currMax = 0;
        int max = 0;
        for (int buy = 0, sell = 1; sell < prices.length; ++sell) {
            if (prices[sell] < prices[sell - 1]) {
                buy = sell;
                max += currMax;
                currMax = 0;
            } else {
                currMax = prices[sell] - prices[buy];
            }   
        }
        return max + currMax;
    }
}
```
123. Best Time to Buy and Sell Stock III

Say you have an array for which the ith element is the price of a given stock on day i.

Design an algorithm to find the maximum profit. You may complete at most two transactions.

Note:
You may not engage in multiple transactions at the same time (ie, you must sell the stock before you buy again).
```java
/*
1.0 wrong approach: try to update the top 2 maxProfit, then add them together, 
the problem is may lose a larger profit(for example 1,4,2,7,2,9)
2.0 the right approach will be using divide and conquer, and DP
we can divide the price array into two non-overlapping subarray, 
then find the max for the (first part add second part)
*/
class Solution {
    public int maxProfit(int[] prices) {
        if (prices == null || prices.length < 2) {
            return 0;
        }
        int n = prices.length;
        int[] left = new int[n];
        int[] right = new int[n];
        int lowestPrice = prices[0];
        for (int i = 1; i < n; ++i) {
            lowestPrice = Math.min(lowestPrice, prices[i]);
            left[i] = Math.max(left[i - 1], prices[i] - lowestPrice);
        }
        int highestPrice = prices[n - 1];
        for (int i = n -2; i >= 0; --i) {
            highestPrice = Math.max(highestPrice, prices[i]);
            right[i] = Math.max(right[i + 1], highestPrice - prices[i]);
        }
        int max = right[0];
        for (int i = 0; i < n - 1; ++i) {
            max = Math.max(max, left[i] + right[i + 1]);
        }
        return max;
    }
}
```
124. Binary Tree Maximum Path Sum

Given a binary tree, find the maximum path sum.

For this problem, a path is defined as any sequence of nodes from some starting node to any node in the tree along the parent-child connections. The path must contain at least one node and does not need to go through the root.

For example:
Given the below binary tree,

       1
      / \
     2   3
Return 6.
```java
/* time O(n)   trick: use array instead of use golal var
idea is dfs, for each side left or right, use the max(0, pathmax(node))
to skip nagative value
for each root, update the max(max, left + root + right);
we still may possiablly find a larger max by going up by adding more node
so we have to return the max(left, right) + root to the top.
 */
class Solution {
    public int maxPathSum(TreeNode root) {
        int[] max = new int[] {Integer.MIN_VALUE};
        maxPathSumHelper(root, max);
        return max[0];
    }
    public int maxPathSumHelper(TreeNode root, int[] max) {
        if (root == null) {
            return 0;
        }
        int left = Math.max(0, maxPathSumHelper(root.left, max));
        int right = Math.max(0, maxPathSumHelper(root.right, max));
        max[0] = Math.max(max[0], left + root.val + right);
        return Math.max(left, right) + root.val;
    }
}
```
125. Valid Palindrome

Given a string, determine if it is a palindrome, considering only alphanumeric characters and ignoring cases.

For example,
"A man, a plan, a canal: Panama" is a palindrome.
"race a car" is not a palindrome.

Note:
Have you consider that the string might be empty? This is a good question to ask during an interview.

For the purpose of this problem, we define empty string as valid palindrome.
```java
/*
use two pointer(left and right) to check, if any pair are not matching, return false
otherwise, the left go beyond the right, return true
*/
class Solution {
    public boolean isPalindrome(String s) {
        if (s == null || s.length() < 2) {
            return true;
        }
        s = s.toLowerCase();
        int left = 0;
        int right = s.length() - 1;
        while (left <= right) {
            while (left <= right && !isValid(s.charAt(left))) {
                ++left;
            }
            while (left <= right && !isValid(s.charAt(right))) {
                --right;
            }
            if (left <= right && s.charAt(left) != s.charAt(right)) {
                return false;
            }
            ++left;
            --right;
        }
        return true;
    }
    public boolean isValid(char c) {
        return (c >= 'a' && c <= 'z') || (c >= '0' && c <= '9');
    }
}
```
127. Word Ladder

Given two words (beginWord and endWord), and a dictionary's word list, find the length of shortest transformation sequence from beginWord to endWord, such that:

Only one letter can be changed at a time.
Each transformed word must exist in the word list. Note that beginWord is not a transformed word.
For example,

Given:
beginWord = "hit"
endWord = "cog"
wordList = ["hot","dot","dog","lot","log","cog"]
As one shortest transformation is "hit" -> "hot" -> "dot" -> "dog" -> "cog",
return its length 5.

Note:
Return 0 if there is no such transformation sequence.
All words have the same length.
All words contain only lowercase alphabetic characters.
You may assume no duplicates in the word list.
You may assume beginWord and endWord are non-empty and are not the same.

```java
/*
the idea is using two way bfs, as it really does not matter which size is begin and end
but if one side getting larger and larger it could become very slow
first, we can put the beginword and endword into two set,
start from the begin set, get all the neighbor of all the words in the begin set, into a newBegin set
update the level + 1;
then if the newBegin.size greater then end.size, swap them when calling the helper fucntion.
*/
class Solution {
    public int ladderLength(String beginWord, String endWord, List<String> wordList) {
        Set<String> bank = new HashSet<>(wordList);
        Set<String> begin = new HashSet<>(Arrays.asList(beginWord));
        Set<String> end = new HashSet<>(Arrays.asList(endWord));
        return bank.contains(endWord) ? ladderLengthHelper(end, begin, bank, new int[]{1}) : 0;        
    }
    public int ladderLengthHelper(Set<String> begin, Set<String> end, Set<String> bank, int[] level) {
        if (begin.size() == 0) {
            return 0;
        }
        ++level[0];
        Set<String> newBegin = new HashSet<>();
        for (String s: begin) {
            char[] c = s.toCharArray();
            for (int i = 0; i < c.length; ++i) {
                char tem = c[i];
                for (char ch = 'a'; ch <= 'z'; ++ch) {
                    c[i] = ch;
                    if (c[i] != tem) {
                        String curr = new String(c);
                        if (end.contains(curr)) {
                            return level[0];
                        }
                        if (bank.contains(curr)) {
                            newBegin.add(curr);
                            bank.remove(curr);
                        }
                    } 
                }
                c[i] = tem;
            }
        }     
        return newBegin.size() > end.size() ? ladderLengthHelper(end, newBegin, bank, level) : 
        ladderLengthHelper(newBegin, end, bank, level);
    }
}
```
128. Longest Consecutive Sequence

Given an unsorted array of integers, find the length of the longest consecutive elements sequence.

For example,
Given [100, 4, 200, 1, 3, 2],
The longest consecutive elements sequence is [1, 2, 3, 4]. Return its length: 4.

Your algorithm should run in O(n) complexity.
```java
/*
idea is add all the number to a set, then traversal each number check if its neighbor is in the set,
if yes, update the length, add remove the neighbor from the set,
otherwise, continue for the next number
*/
class Solution {
    public int longestConsecutive(int[] nums) {
        if (nums == null || nums.length == 0) {
            return 0;
        }
        int longest = 0;
        Set<Integer> set = new HashSet<>();
        for (int n : nums) {
            set.add(n);
        }
        for (int n : nums) {
            int tem = n;
            int currLongest = 1;
            while (set.remove(++n)) {
                ++currLongest;
            }
            while (set.remove(--tem)) {
                ++currLongest;
            }
            longest = Math.max(longest, currLongest);
        }
        return longest;
    }
}
```
129. Sum Root to Leaf Numbers

Given a binary tree containing digits from 0-9 only, each root-to-leaf path could represent a number.

An example is the root-to-leaf path 1->2->3 which represents the number 123.

Find the total sum of all root-to-leaf numbers.

For example,

    1
   / \
  2   3
The root-to-leaf path 1->2 represents the number 12.
The root-to-leaf path 1->3 represents the number 13.

Return the sum = 12 + 13 = 25.
```java
/* recursion
if the node is a leaf, add the sum to the total array,
otherwise, pass the current sum to helper function, for left and right subtree
 */
class Solution {
    public int sumNumbers(TreeNode root) {
        if (root == null) {
            return 0;
        }
        int[] total = new int[]{0};
        sumNumbersHelper(root, root.val, total);
        return total[0];
    }
    public void sumNumbersHelper(TreeNode root, int sum, int[] total) {
        if (root.left == null && root.right == null) {
            total[0] += sum;
        }
        if (root.left != null) {
            sumNumbersHelper(root.left, sum * 10 + root.left.val, total);
        }
        if (root.right != null) {
            sumNumbersHelper(root.right, sum * 10 + root.right.val, total);
        }
    }
}
/**
the first idea is level traversal, use two queue/stack(same), one for node, one for the current total.
then everytime find a leaf, we add that total to the sum
otherwise, we push the non - null node to the queue, and the updateed currenttotal to the value queue.
*/
//iterative approach
class Solution {
    public int sumNumbers(TreeNode root) {
        if (root == null) return 0;   
        Queue<TreeNode> nodes = new LinkedList<>();
        Queue<Integer> total = new LinkedList<>();     
        nodes.offer(root);
        total.offer(root.val);     
        int sum = 0;        
        while (!nodes.isEmpty()) {
            TreeNode head = nodes.poll();
            int currentTotal = total.poll();            
            if (head.left == null && head.right == null) sum += currentTotal;      
            if (head.left != null) {
                nodes.offer(head.left);
                total.offer(currentTotal * 10 + head.left.val);
            }         
            if (head.right != null) {
                nodes.offer(head.right);
                total.offer(currentTotal * 10 + head.right.val);
            }
        }
        return sum;
    }
}

```
130. Surrounded Regions

Given a 2D board containing 'X' and 'O' (the letter O), capture all regions surrounded by 'X'.

A region is captured by flipping all 'O's into 'X's in that surrounded region.

For example,
X X X X
X O O X
X X O X
X O X X
After running your function, the board should be:

X X X X
X X X X
X X X X
X O X X
```java
/*
idea is mark all the regions can not be captured to '?' from the edges
then the left Os are able to be captured, set them to X,
then change all the '?' back to O
**important**
1. first must only explore from the 4 edges
2. then when capture and reset the board, we can do in in one pass, but need to do the capture first
*/
class Solution {
    public void solve(char[][] board) {
        if (board == null || board.length == 0 || board[0] == null || board[0].length == 0) {
            return;
        }
        for (int r = 0; r < board.length; ++r) {
            solveHelper(board, r, 0);
            solveHelper(board, r, board[0].length - 1);
        }
        for (int c = 0; c < board[0].length; ++c) {
            solveHelper(board, 0, c);
            solveHelper(board, board.length - 1, c);
        }
        for (int r = 0; r < board.length; ++r) {
            for (int c = 0; c < board[0].length; ++c) {
                if (board[r][c] == 'O') {
                    board[r][c] = 'X';
                }
                if (board[r][c] == '?') {
                    board[r][c] = 'O';
                }
            }
        }
    }
    public void solveHelper(char[][] board, int row, int col) {
        if (row < 0 || row >= board.length || col < 0 || col >= board[0].length) {
            return;
        }
        if (board[row][col] == 'X' || board[row][col] == '?') {
            return;
        }
        if (board[row][col] == 'O') {
            board[row][col] = '?';
        }
        solveHelper(board, row + 1, col);
        solveHelper(board, row, col + 1);
        solveHelper(board, row - 1, col);
        solveHelper(board, row, col - 1);
    }
}
```
131. Palindrome Partitioning

Given a string s, partition s such that every substring of the partition is a palindrome.

Return all possible palindrome partitioning of s.

For example, given s = "aab",
Return

  ["aa","b"],
  ["a","a","b"]

```java
/*
idea is do the subset, then only add palindrome subset to the result list
use a for loop, check all the substrings, 
the substring will always start at 0, and end at i + 1, then pass the rest substring to the helper
*/
class Solution {
    public List<List<String>> partition(String s) {
        List<List<String>> res = new ArrayList<List<String>>();
        if (s == null || s.length() == 0) {
            return res;
        }
        partitionHelper(s, res, new ArrayList<>());
        return res;
    }
    public void partitionHelper(String s, List<List<String>> res, List<String> curr) {
        if (s.length() == 0) {
            res.add(new ArrayList<>(curr));
            return;
        }
        for (int i = 0; i < s.length(); ++i) {
            if (isPalindrome(s.substring(0, i+1))) {
                curr.add(s.substring(0, i+1));
                partitionHelper(s.substring(i+1), res, curr);
                curr.remove(curr.size() - 1);
            }
        }
    }
    public boolean isPalindrome(String s) {
        int left = 0;
        int right = s.length() - 1;
        while (left < right) {
            if (s.charAt(left++) != s.charAt(right--)) {
                return false;
            }
        }
        return true;
    }
}
```
133. Clone Graph

Clone an undirected graph. Each node in the graph contains a label and a list of its neighbors.

OJ's undirected graph serialization:
Nodes are labeled uniquely.

We use # as a separator for each node, and , as a separator for node label and each neighbor of the node.
As an example, consider the serialized graph {0,1,2#1,2#2,2}.

The graph has a total of three nodes, and therefore contains three parts as separated by #.

First node is labeled as 0. Connect node 0 to both nodes 1 and 2.
Second node is labeled as 1. Connect node 1 to node 2.
Third node is labeled as 2. Connect node 2 to node 2 (itself), thus forming a self-cycle.
```java
/**
 * Definition for undirected graph.
 * class UndirectedGraphNode {
 *     int label;
 *     List<UndirectedGraphNode> neighbors;
 *     UndirectedGraphNode(int x) { label = x; neighbors = new ArrayList<UndirectedGraphNode>(); }
 * };
*the idea is using a map k: older node, v: new node(copy), build the relation
use a queue for the node is about to explore, prevent explore visited node
for each node, if we havenot explored it, we should add it to the map and push it to the queue
**important** but, no matter what, we have to copy the relationship between each pair of nodes
 */
public class Solution {
    public UndirectedGraphNode cloneGraph(UndirectedGraphNode node) {
        if (node == null) {
            return null;
        }
        Map<UndirectedGraphNode, UndirectedGraphNode> map = new HashMap<>();
        map.put(node, new UndirectedGraphNode(node.label));
        Deque<UndirectedGraphNode> queue = new ArrayDeque<>();
        queue.offer(node);
        while (!queue.isEmpty()) {
            UndirectedGraphNode head = queue.poll();
            for (UndirectedGraphNode neighbor: head.neighbors) {
                if (!map.containsKey(neighbor)) {
                    queue.offer(neighbor);
                    map.put(neighbor, new UndirectedGraphNode(neighbor.label));
                }
                map.get(head).neighbors.add(map.get(neighbor));
            }
        }
        return map.get(node);
    }
}
```
134. Gas Station

There are N gas stations along a circular route, where the amount of gas at station i is gas[i].

You have a car with an unlimited gas tank and it costs cost[i] of gas to travel from station i to its next station (i+1). You begin the journey with an empty tank at one of the gas stations.

Return the starting gas station's index if you can travel around the circuit once, otherwise return -1.
```java
// some important point (can optimize to ONE pass)
//1. if the total gas is less than the total cost, we can not make it for sure.
//      otherwise, there is must be a way we can make it
//2. if we know we can eventually make it, and from the start point to any point we failed, 
based on this logic there is no way we can make it to start at any point between them, 
we must have at least a zero remainder to the next station, 
but if we start at any of those point, for sure, we can never get a better remainder. 
//this means, the start point is must after the failed point.
//3. when we choose a new start point, we must reset the remainder to zero as well.
class Solution {
    public int canCompleteCircuit(int[] gas, int[] cost) {
        int totalCost = 0;
        int totalGas  = 0;
        for (int i = 0; i < gas.length; ++i) {
            totalGas += gas[i];
            totalCost += cost[i];
        }
        if (totalCost > totalGas) {
            return -1;
        }
        int carry = 0;
        int startPoint = 0;
        for (int i = 0; i < gas.length; ++i) {
            if (gas[i] + carry < cost[i]) {
                startPoint = i + 1;
                carry = 0;
            } else {
                carry = gas[i] + carry - cost[i];
            }
        }
        return startPoint;
    }
}
```
135. Candy

There are N children standing in a line. Each child is assigned a rating value.

You are giving candies to these children subjected to the following requirements:

Each child must have at least one candy.
Children with a higher rating get more candies than their neighbors.
What is the minimum candies you must give?
```java
/*
idea is traversal the array from front and back twice.
1. give every one 1 candy first
2. traverse the array from left to right, if current raing higher than the previous, add one more candy to the current
3. however, will miss some cases. for example 1,3,4,2,1, so, we also need to traversal from back to front once,
4. can also use the same logic, only thing is do not lower any number in order to maintain the previous result
*/
class Solution {
    public int candy(int[] ratings) {
        if (ratings == null || ratings.length == 0) {
            return 0;
        }
        int[] give = new int[ratings.length];
        give[0] = 1; 
        for (int i = 1; i < ratings.length; ++i) {
            give[i] = (ratings[i] > ratings[i - 1]) ? give[i - 1] + 1: 1;
        }
        int sum = give[ratings.length - 1];
        for (int i = ratings.length - 2; i >= 0; --i) {
            if (ratings[i] > ratings[i + 1]) {
                give[i] = Math.max(give[i], give[i + 1] + 1);
            }
            sum += give[i];
        }
        return sum;
    }
}
```
136. Single Number

Given an array of integers, every element appears twice except for one. Find that single one.

Note:
Your algorithm should have a linear runtime complexity. Could you implement it without using extra memory?
```java
//serveral solutions, use set, map, or sort the array.
//however, those sulution eigher need extra space or more than linear runtime.
// so for this perticular requirment, we have to use bit minipulation to do
//^ means, if different return 1, if same return 0,
//so, if we do a ^ operation for each num in the array, the left number will be the single number.

class Solution {
    public int singleNumber(int[] nums) {
        int res = 0;       
        for (int num: nums) {
            res ^= num;
        }     
        return res;
    }
}
class Solution {
    public int singleNumber(int[] nums) {
        Set<Integer> hs = new HashSet<>();       
        for (int num: nums) {
            if (!hs.remove(num)) {
                hs.add(num);
            }
        }
        return hs.iterator().next();
    }
}

```
138. Copy List with Random Pointer

A linked list is given such that each node contains an additional random pointer which could point to any node in the list or null.

Return a deep copy of the list.
```java
//idea is traverse the list twice, first time only copy the label of each node,
and use a map to pair the old list with the new list,
//during the second traversal, we can easily copy the pointer.
public class Solution {
    public RandomListNode copyRandomList(RandomListNode head) {
        if (head == null) {
            return null;
        }
        RandomListNode tail = head;
        Map<RandomListNode, RandomListNode> map = new HashMap<>();
        while (tail != null) {
            map.put(tail, new RandomListNode(tail.label));
            tail = tail.next;
        }
        tail = head;
        while (tail != null) {
            map.get(tail).next = map.get(tail.next);
            map.get(tail).random = map.get(tail.random);
            tail = tail.next;
        }
        return map.get(head);
    }
}
```
139. Word Break

Given a non-empty string s and a dictionary wordDict containing a list of non-empty words, determine if s can be segmented into a space-separated sequence of one or more dictionary words. You may assume the dictionary does not contain duplicate words.

For example, given
s = "leetcode",
dict = ["leet", "code"].

Return true because "leetcode" can be segmented as "leet code".
```java
/*
the idea is devide the problem into sub problems, using DP
if the last word is in the bank, and the rest part before the last word can be break, 
that means the whole word is can be break, same logic for any point int the give string
**till index i**, if the substring is in the set, and the other part of the string are breakable, 
that means the whole string is also braekable. **till index i**
optimization: the substring can not be longer than the longest word in the set
*/
class Solution {
    public boolean wordBreak(String s, List<String> wordDict) {
        Set<String> bank = new HashSet<>(wordDict);
        boolean[] breakable = new boolean[s.length() + 1];
        int longest = longestWord(bank);
        breakable[0] = true;
        for (int i = 1; i <= s.length(); ++i) {
            for (int j = i - 1; !breakable[i] && j >= 0 && j >= i - longest; --j) {
                breakable[i] = bank.contains(s.substring(j, i)) && breakable[j];
            }
        }
        return breakable[s.length()];
    }
    public int longestWord (Set<String> bank) {
        int longest = 0;
        for (String s: bank) {
            longest = Math.max(longest, s.length());
        }
        return longest;
    }
}
```
140. Word Break II

Given a non-empty string s and a dictionary wordDict containing a list of non-empty words, add spaces in s to construct a sentence where each word is a valid dictionary word. You may assume the dictionary does not contain duplicate words.

Return all such possible sentences.

For example, given
s = "catsanddog",
dict = ["cat", "cats", "and", "sand", "dog"].

A solution is ["cats and dog", "cat sand dog"].
```java
/*
the idea is first caching all the breakable point in a boolean array using dp. O(n2)
then, use dfs + backtracking, only add word when the current index is breakable, and word is in the bank
also can use the longestWord function to do optimization
*/
class Solution {
    public List<String> wordBreak(String s, List<String> wordDict) {
        List<String> res = new ArrayList<>();
        Set<String> bank = new HashSet<>(wordDict);
        boolean[] breakable = new boolean[s.length() + 1];
        int longestWord = findLongestWord(bank);
        breakableHelper(s, bank, breakable, longestWord);
        if (!breakable[s.length()]) {
            return res;
        }
        wordBreakHelper(s, bank, breakable, res, new StringBuilder(), 0, longestWord);
        return res;
    }
    public void wordBreakHelper(String s, Set<String> bank, boolean[] breakable, 
    List<String> res, StringBuilder curr, int index, int longestWord) {
        if (index == s.length()) {
            res.add(curr.substring(1));
            return;
        }
        for (int i = index; i < s.length() && i < index + longestWord; ++i) {
            if (breakable[i + 1] && bank.contains(s.substring(index, i + 1))) {
                int size = curr.length();
                curr.append(" ").append(s.substring(index, i + 1));
                wordBreakHelper(s, bank, breakable, res, curr, i + 1, longestWord);
                curr.setLength(size);
            }
        }
    }
    public void breakableHelper(String s, Set<String> bank, boolean[] breakable, int longestWord) {
        breakable[0] = true;
        for (int i = 1; i <= s.length(); ++i) {
            for (int j = i - 1; !breakable[i] && j >= 0 && j >= i - longestWord; --j) {
                breakable[i] = bank.contains(s.substring(j, i)) && breakable[j];
            }
        }
    }
    public int findLongestWord (Set<String> bank) {
        int longest = 0;
        for (String s: bank) {
            longest = Math.max(longest, s.length());
        }
        return longest;
    }
}

//alternative wordBreakhelper function
    // public void wordBreakhelper(String s, Set<String> wordSet, String curr, List<String> res, int index, boolean[] breakable, int maxLength) {
    //     if(index == s.length()) {
    //         res.add(curr);
    //     } else if(breakable[index]) { //only process the next step if the current index is breakable
    //         for (int i = 1; index + i <= s.length() && i <= maxLength; ++i) {
    //             curr +=  (index == 0 ? "": " ") + s.substring(index, index + i);
    //             if(wordSet.contains(sub))
    //                 wordBreakhelper(s, wordSet, curr, res, index + i, breakable, maxLength);
    //         }
    //     }
    // }
```
141. Linked List Cycle

Given a linked list, determine if it has a cycle in it.

Follow up:
Can you solve it without using extra space?
```java
/* use two pointer, slow and fast,
if there is a cycle, the slow will eventually catch the fast,
otherwise, the fast will reach to the end first
 */
public class Solution {
    public boolean hasCycle(ListNode head) {
        if (head == null || head.next == null) {
            return false;
        }
        ListNode slow = head;
        ListNode fast = head.next;
        while (fast != slow && fast != null && fast.next != null) {
            slow = slow.next;
            fast = fast.next.next;
        }
        return fast == slow;
    }
}
```
142. Linked List Cycle II

Given a linked list, return the node where the cycle begins. If there is no cycle, return null.

Note: Do not modify the linked list.

Follow up:
Can you solve it without using extra space?
![20171230_154114000_iOS](/content/images/2017/12/20171230_154114000_iOS.jpg)
```java
/* time O(n), space O(1)
idea is use two pointer, slow and fast, fast go two time fast than slow
if they eventually meet, then, fast pointer must travels two time distance than slow,
by draw a simple diagram, we will know, distance from start to the cycle start point
is as same as the distance from the meet point to the cycle start point
 */
public class Solution {
    public ListNode detectCycle(ListNode head) {
        if (head == null || head.next == null) {
            return null;
        }
        ListNode fast = head;
        ListNode slow = head;
        while (fast != null && fast.next != null) {
            fast = fast.next.next;
            slow = slow.next;
            if (fast == slow) {
                slow = head;
                while (fast != slow) {
                    fast = fast.next;
                    slow = slow.next;
                }
                return fast;
            }
        }
        return null;
    }
}
```
143. Reorder List

Given a singly linked list L: L0→L1→…→Ln-1→Ln,
reorder it to: L0→Ln→L1→Ln-1→L2→Ln-2→…

You must do this in-place without altering the nodes' values.

For example,
Given {1,2,3,4}, reorder it to {1,4,2,3}.
```java
/* idea is use two pointer slow and fast find the middle point, then reverse the second half
then merge them tegether,
**very important** for the megerHelper function, it should be second != null,
because, the first helf may have one more node than then second half (like A, B, C)
 */
class Solution {
    public void reorderList(ListNode head) {
        if (head == null || head.next == null) {
            return;
        }
        ListNode slow = head;
        ListNode fast = head.next;
        while (fast != null && fast.next != null) {
            slow = slow.next;
            fast = fast.next.next;
        }
        ListNode second = reverse(slow.next);
        slow.next = null;
        mergeHelper(head, second);
    }
    public void mergeHelper(ListNode head, ListNode second) {
        ListNode first = head;
        while (second != null) {
            ListNode next = first.next;
            first.next = second;
            first = first.next;          
            second = second.next;
            first.next = next;
            first = first.next;
        }
    }
    public ListNode reverse(ListNode head) {
        if (head == null || head.next == null) {
            return head;
        }
        ListNode pre = head;
        ListNode curr = head.next;
        ListNode next = curr.next;
        pre.next = null;
        while (curr != null) {
            curr.next = pre;
            if (next == null) {
                break;
            }
            pre = curr;
            curr = next;
            next = next.next;
        }
        return curr;
    }
}
```
144. Binary Tree Preorder Traversal

```java
//O(1) space
class Solution {
    public List<Integer> preorderTraversal(TreeNode root) {
        List<Integer> res = new ArrayList<Integer>();
        TreeNode head = root;
        while (head != null) {
            if (head.left == null) {
                res.add(head.val);
                head = head.right;
            } else { 
                TreeNode pre = head.left;                
                while (pre.right != null && pre.right != head) {
                    pre = pre.right;
                }
                if (pre.right == null) {
                    pre.right = head;
                    res.add(head.val);
                    head = head.left;
                } else {
                    head = head.right;
                    pre.right = null;
                }
            }
        }
        return res;
    }
}
//iterative
class Solution {
    public List<Integer> preorderTraversal(TreeNode root) {
        List<Integer> res = new ArrayList<Integer>();        
        Deque<TreeNode> stack = new ArrayDeque<>();
        TreeNode head = root;
        while (head != null || !stack.isEmpty()) {
            while (head != null) {
                res.add(head.val);
                stack.push(head);
                head = head.left;
            }
            head = stack.pop();
            head = head.right;
        }
        return res;
    }
}
//recursion
class Solution {
    public List<Integer> preorderTraversal(TreeNode root) {
        List<Integer> res = new ArrayList<Integer>();
        preorder(res, root);        
        return res;   
    }
    public void preorder(List<Integer> res, TreeNode root){
        if (root == null) {
            return;
        }
        res.add(root.val);
        preorder(res, root.left);
        preorder(res, root.right);
    }
}
```
145. Binary Tree Postorder Traversal


```java
/*
the idea is use a lastVisit node to keep tracking the lastVisit node after we print a node
after reach to the most left node, peek from the stack, because this node, we may or may not print it,
only print, pop node from stack when the peek node does not have a right node, or we have visited its right node
otherwise, we can just continue to explore its right subtree/
 */
class Solution {
    public List<Integer> postorderTraversal(TreeNode root) {
        List<Integer> res = new ArrayList<Integer>();
        TreeNode head = root;
        TreeNode lastVisit = null;
        Deque<TreeNode> stack = new ArrayDeque<>();
        while (head != null || !stack.isEmpty()) {
            while (head != null) {
                stack.push(head);
                head = head.left;
            }
            head = stack.peek();
            if (head.right == null || head.right == lastVisit) {
                lastVisit = head;
                res.add(stack.pop().val);
                head = null;
            } else {
                head = head.right;
            }
        }
        return res;
    }
}
```
146. LRU Cache

Design and implement a data structure for Least Recently Used (LRU) cache. It should support the following operations: get and put.

get(key) - Get the value (will always be positive) of the key if the key exists in the cache, otherwise return -1.
put(key, value) - Set or insert the value if the key is not already present. When the cache reached its capacity, it should invalidate the least recently used item before inserting a new item.

Follow up:
Could you do both operations in O(1) time complexity?
```java
/*
thought: what data structure to store the data? as we always need to move the data
if use a list, you need O(n) time to get, (also remove, because you still need to locate to the node first then remove)
idea is implement a doubly linkedlist(with prev and next pointer) to store the data,
then use a hashmap to map the key with the list node
then, we can use O(1) time to get the value by using hashmap,
and also O(1) time to remove and insert the node by using the doubly linkedlist
*all the code is important, must read*
*/
class LRUCache {
    class Node {
        int key;
        int value;
        Node next;
        Node prev;
        public Node(int key, int value) {
            this.key = key;
            this.value = value;
        }
    }
    int capacity;
    int count;
    Map<Integer, Node> map;
    Node dummyHead;
    Node dummyTail;
    public LRUCache(int capacity) {
        this.capacity = capacity;
        map = new HashMap<>();
        dummyHead = new Node(0, 0);
        dummyTail = new Node(0, 0);
        dummyHead.next = dummyTail;
        dummyTail.prev = dummyHead;
    }
    /*
    if the key is in the map, get the node, then remove the node, then set the node to the head
    optimizationL: if the node is already in the head, just return the value
    */
    public int get(int key) {
        if (map.containsKey(key)) {
            Node curr = map.get(key);
            if (dummyHead.next == curr) {
                return curr.value;
            }
            remove(curr);
            moveToHead(curr);
            return curr.value;
        }
        return -1;
    }
    /*
    if the key is not in the map(means insert), create new node, set to the head
        after insert new node, if the number of node greater than the capacity, 
        **important** remove the lastnode from both list and map, then decrement the count
    if the key is in the map(means replace), remove the node, move the node to the head
    */
    public void put(int key, int value) {
        if (!map.containsKey(key)) {
            Node head = new Node(key, value);
            map.put(key, head);
            moveToHead(head);
            if (++count > capacity) {
                Node lastNode = dummyTail.prev;
                remove(lastNode);
                map.remove(lastNode.key);
                --count;
            }
        } else {
            Node curr = map.get(key);
            curr.value = value;
            remove(curr);
            moveToHead(curr);
        }
    }
    //update the prev and next pointer to remove the current node
    public void remove(Node node) {
        node.prev.next = node.next;
        node.next.prev = node.prev;
        /*
        following commented code are not necessary, but good to have, 
        beucase after remove the node, there are two cases
        1. we do not need the node any more, it will go to the GC
        2. we do need to move it to the head, and we will update its prev and next pointer anyway
        */
        // node.prev = null;
        // node.next = null;
    }
    public void moveToHead(Node node) {
        Node oldHead = dummyHead.next;
        dummyHead.next = node;
        node.prev = dummyHead;
        node.next = oldHead;
        oldHead.prev = node;
    }
}

/**
 * Your LRUCache object will be instantiated and called as such:
 * LRUCache obj = new LRUCache(capacity);
 * int param_1 = obj.get(key);
 * obj.put(key,value);
 */
```
147. Insertion Sort List

Sort a linked list using insertion sort.
```java
/* idea is use pre curr two pointer, scan the list, then find the right place to insert between the pre and curr, 
by keep moving and reseting the pre, curr.
 */
class Solution {
    public ListNode insertionSortList(ListNode head) {
        if (head == null || head.next == null) {
            return head;
        }
        ListNode dummy = new ListNode(0);
        ListNode pre = dummy;
        ListNode curr = head;
        pre.next = curr;
        head = head.next;
        curr.next = null;
        while (head != null) {
            //when curr is null means the curr reached to the end, 
            //means the current head is larger than all the existing nodes
            if (curr == null || head.val < curr.val) {
                pre.next = head;
                head = head.next;
                pre.next.next = curr;
                pre = dummy;
                curr = pre.next;
            } else {
                pre = pre.next;
                curr = curr.next;
            }
        }
        return dummy.next;
    }
}
```
149. Max Points on a Line

Given n points on a 2D plane, find the maximum number of points that lie on the same straight line.
```java
/* idea is calculate the slope for each two point, in fraction in lowest term format(cause double is not accurate)
use a map, slope as key, count as value
**important things**
0. for each point, we have to use a new map
1. points has x, or y in common, can not calculate slope, so just use two variables to track the count
2. if there is a duplicate point, increment the samePoint, do not just directly increment the localmax, 
must add to the localMax lastly, because all the lines shares that points, they all potentially can be the localmax,
but simply increment the localmax will prevent they become to the localmax
3. use fraction in lowest term to express the slope
4. update the global max
 */
class Solution {
    public int maxPoints(Point[] points) {
        if (points == null || points.length < 1) {
            return 0;
        }
        int max = 1;
        for (int i = 0; i < points.length; ++i) {
            Map<String, Integer> map = new HashMap<>();
            Point p1 = points[i];
            int localMax = 1;
            int samePoint = 0;
            int ver = 1;
            int hor = 1;
            for (int j = i + 1; j < points.length; ++j) {
                Point p2 = points[j];
                if (p1.x == p2.x && p1.y == p2.y) {
                    ++samePoint;
                } else if (p1.x == p2.x) {
                    localMax = Math.max(localMax, ++hor);
                } else if (p1.y == p2.y) {
                    localMax = Math.max(localMax, ++ver);
                } else if (p1.x != p2.x && p1.y != p2.y) {
                    int gcd = getGcd(p1.x - p2.x, p1.y - p2.y);
                    String slope = (p1.x - p2.x) / gcd + "/" + (p1.y - p2.y) / gcd;
                    map.put(slope, map.getOrDefault(slope, 1) + 1);
                    localMax = Math.max(localMax, map.get(slope));
                }  
            }
            max = Math.max(max, localMax + samePoint);
        }
        return max;
    }
    public int getGcd(int a, int b) {
        if (a == 0) {
            return b;
        }
        return getGcd(b % a, a);
    } 
}
```
150. Evaluate Reverse Polish Notation

Evaluate the value of an arithmetic expression in Reverse Polish Notation.

Valid operators are +, -, *, /. Each operand may be an integer or another expression.

Some examples:
  ["2", "1", "+", "3", "*"] -> ((2 + 1) * 3) -> 9
  ["4", "13", "5", "/", "+"] -> (4 + (13 / 5)) -> 6
```java
/* ask the range of the numbers
idea is use a stack, when see a operators, pop two numbers
if you really want to valid the numbers, make sure to check if the first position is "+" or "-"
*/
class Solution {
    public int evalRPN(String[] tokens) {
        if (tokens == null || tokens.length == 0) {
            return 0;
        }
        Deque<String> stack = new ArrayDeque<>();
        for (String token: tokens) {
            if (isOperator(token)) {
                if (stack.size() < 2 || token.equals("/") && stack.peek().equals("0")) {
                    return 0;
                }
                int number2 = Integer.parseInt(stack.pop());
                int number1 = Integer.parseInt(stack.pop());
                stack.push(calculate(number1, number2, token));
            } else if (isNumber(token)) {
                stack.push(token);
            } else {
                return 0;
            }
        }
        return Integer.parseInt(stack.peek());
    }
    public boolean isOperator(String s) {
        return s.equals("+") || s.equals("-") || s.equals("*") || s.equals("/");
    }
    public boolean isNumber(String s) {
        for (int i = 0; i < s.length(); ++i) {
            char c = s.charAt(i);
            if (i == 0 && c == '+' || c == '-') {
                continue;
            }
            if (c < '0' || c > '9') {
                return false;
            }
        }
        return true;
    }
    public String calculate(int n1, int n2, String operator) {
        if (operator.equals("+")) {
            return String.valueOf(n1 + n2);
        } else if (operator.equals("-")) {
            return String.valueOf(n1 - n2);
        } else if (operator.equals("*")) {
            return String.valueOf(n1 * n2);
        } else {
            return String.valueOf(n1 / n2);
        }
    }
}
```
151. Reverse Words in a String

Given an input string, reverse the string word by word.

For example,
Given s = "the sky is blue",
return "blue is sky the".

Update (2015-02-12):
For C programmers: Try to solve it in-place in O(1) space.

click to show clarification.

Clarification:
What constitutes a word?
A sequence of non-space characters constitutes a word.
Could the input string contain leading or trailing spaces?
Yes. However, your reversed string should not contain leading or trailing spaces.
How about multiple spaces between two words?
Reduce them to a single space in the reversed string.
```java
/*
idea is keep insert char to the front, when meet a space, update the offset, 
be careful of the leading, tailing, and extra space,
if need to do it in place, then just reverse the whole thing first, then reverse each words
*/
public class Solution {
    public String reverseWords(String s) {
        if (s == null || s.length() == 0) {
            return s;
        }
        StringBuilder res = new StringBuilder();
        int offset = 0;
        for (int i = s.length() - 1; i >= 0; --i) {
            char curr = s.charAt(i);
            if (i == s.length() - 1 && curr == ' ') {
                continue;
            }
            if (curr != ' ') {
                res.insert(offset, curr);
            } else {
                if (s.charAt(i + 1) == ' ') {
                    continue;
                }
                res.append(curr);
                offset = res.length();
            }
        }
        if (res.length() > 0 && res.charAt(res.length() - 1) == ' ') {
            res.deleteCharAt(res.length() - 1);
        }
        return res.toString();
    }
}
```
152. Maximum Product Subarray

Find the contiguous subarray within an array (containing at least one number) which has the largest product.

For example, given the array [2,3,-2,4],
the contiguous subarray [2,3] has the largest product = 6.
```java
/*
input  -1   6   -2    -3
max    -1   6   12    36 
min    -1   -6  -12   -36
idea is maintain two array to cache all the max and min sums, because the array may contain nagative numbers,
and two nagative number actually potentially can turn into a larger positive number
can be optimized to O(1) spcae, using premax, premin, currmax, currmin 4 variables
*/
class Solution {
    public int maxProduct(int[] nums) {
        if (nums == null || nums.length == 0) {
            return -1;
        }
        int res = nums[0];
        int preMax = nums[0];
        int preMin = nums[0];
        for (int i = 1; i < nums.length; ++i) {
            int currMax = Math.max(nums[i], Math.max(nums[i] * preMax, nums[i] * preMin));
            int currMin = Math.min(nums[i], Math.min(nums[i] * preMax, nums[i] * preMin));
            res = Math.max(res, currMax);
            preMax = currMax;
            preMin = currMin;
        }
        return res;
    }
}
```
153. Find Minimum in Rotated Sorted Array

Suppose an array sorted in ascending order is rotated at some pivot unknown to you beforehand.

(i.e., 0 1 2 4 5 6 7 might become 4 5 6 7 0 1 2).

Find the minimum element.

You may assume no duplicate exists in the array.
```java
class Solution {
    public int findMin(int[] nums) {
        if (nums == null || nums.length == 0) {
            return 0;
        }
        int left = 0;
        int right = nums.length - 1;
        while (left + 1 < right) {
            int mid = (right - left) / 2 + left;
            if (nums[mid] > nums[right]) {
                left = mid;
            } else {
                right = mid;
            }
        }
        return Math.min(nums[left], nums[right]);
    }
}
```
154. Find Minimum in Rotated Sorted Array II

Follow up for "Find Minimum in Rotated Sorted Array":
What if duplicates are allowed?

Would this affect the run-time complexity? How and why?
```java
/*
the idea is skip all the duplicate element,
as we comparing the mid with right, we can only care about right first, 
if right == left, skip all the duplicate right, for example 0,2,3,4,0,0
we can not move right and left together, because, if we do so, we may skip the result(0,1,2,3,0), 
or we may missing some duplicates(5,2,3,4,5,5,5,5)
*/
class Solution {
    public int findMin(int[] nums) {
        if (nums == null || nums.length == 0) {
            return 0;
        }
        int left = 0;
        int right = nums.length - 1;
        while (left + 1 < right) {
            while (left + 1 < right && nums[right] == nums[left]) {
                --right;
            }
            int mid = (right - left) / 2 + left;
            if (nums[mid] > nums[right]) {
                left = mid;
            } else {
                right = mid;
            }
        }
        return Math.min(nums[left], nums[right]);
    }
}
```
155. Min Stack

Design a stack that supports push, pop, top, and retrieving the minimum element in constant time.

push(x) -- Push element x onto stack.
pop() -- Removes the element on top of the stack.
top() -- Get the top element.
getMin() -- Retrieve the minimum element in the stack.
Example:
MinStack minStack = new MinStack();
minStack.push(-2);
minStack.push(0);
minStack.push(-3);
minStack.getMin();   --> Returns -3.
minStack.pop();
minStack.top();      --> Returns 0.
minStack.getMin();   --> Returns -2.
```java
/*
two idea, first one is using two stack, one for all the number, one for the current min
second idea is make own data structure, use a inner class with int val, int min and a next pointer,
then use Node head global variable.
*/
class MinStack {
    class Node {
        int val;
        int min;
        Node next;
        Node(int val, int min) {
            this.val = val;
            this.min = min;
        }
    }
    private Node head;
    public void push(int x) {
        if (head == null) {
            head = new Node(x, x);
        } else {
            Node newHead = new Node(x, Math.min(x, head.min));
            newHead.next = head;
            head = newHead;
        }
    }
    
    public void pop() {
        if (head != null) {
            head = head.next;
        }
    }
    
    public int top() {
        if (head != null) {
            return head.val;
        }
        return -1;
    }
    
    public int getMin() {
        if (head != null) {
            return head.min;
        }
        return -1;
    }
}
// class MinStack {
//     Deque<Integer> number_stack = new ArrayDeque<>();
//     Deque<Integer> min_stack = new ArrayDeque<>();
//     public void push(int x) {
//         number_stack.push(x);
//         if (min_stack.isEmpty()) {        
//             min_stack.push(x);
//         } else {
//             min_stack.push(Math.min(x, min_stack.peek()));
//         }
//     }    
//     public void pop() {
//         if (!number_stack.isEmpty()) {
//             number_stack.pop();
//             min_stack.pop();
//         }      
//     }    
//     public int top() {
//         if (!number_stack.isEmpty()) {
//             return number_stack.peek();
//         }
//         return -1;
//     }    
//     public int getMin() {
//         if (!min_stack.isEmpty()) {        
//             return min_stack.peek();
//         }
//         return -1;
//     }
// }
```
157. Read N Characters Given Read4

The API: int read4(char *buf) reads 4 characters at a time from a file.
The return value is the actual number of characters read. For example, it returns 3 if there is only 3 characters left in the file.
By using the read4 API, implement the function int read(char *buf, int n) that reads n characters from the file.
Note:
The read function will only be called once for each test case.
```java
/* the idea is use two loops
first one is loop calling the read4 function until count reach to n or the file is ending   
second one keep adding elements to buf until count reach to n or reach to the end of the file
    use a boolean endoffile to indicate it will be the last time to call the read4 function
*/
public class Solution extends Reader4 {
    public int read(char[] buf, int n) {
        int count = 0;
        char[] tem = new char[4];
        boolean endOfFile = false;
        while (count < n && !endOfFile) {
            int size = read4(tem);
            endOfFile = size < 4;
            for (int i = 0; count < n && i < size; ++i) {
                buf[count++] = tem[i];
            }
        }
        return count;
    }
}
```
158. Read N Characters Given Read4 II - Call multiple times

The API: int read4(char *buf) reads 4 characters at a time from a file.
The return value is the actual number of characters read. For example, it returns 3 if there is only 3 characters left in the file.
By using the read4 API, implement the function int read(char *buf, int n) that reads n characters from the file.
Note:
The read function may be called multiple times.

```java
/*
the idea is use a queue, every time call the read function, call the read4 function first and add all to the queue
then determine the minimun add for the current step 
    1. add everything from the queue still did not reach n
    2. reached n, no matter the queue is empty or not
then if the count reach n or size of the read4 is less than 4(means it is end of the file) just break
*/
public class Solution extends Reader4 {
    Queue<Character> queue = new LinkedList<>();
    public int read(char[] buf, int n) {
        int count = 0;
        while(true) {
            char[] tem = new char[4];
            int size = read4(tem);
            for (int i = 0; i < size; ++i) {
                queue.offer(tem[i]);
            }
            int min = Math.min(queue.size(), n - count);
            for (int i = 0; i < min; ++i) {
            //while (queue.size() > 0 && count < n) {
                buf[count++] = queue.poll();
            }
            if (count == n || size < 4) {
                break;
            }
        }
        return count;
    }
}
```
159. Longest Substring with At Most Two Distinct Characters

Given a string, find the length of the longest substring T that contains at most 2 distinct characters.

For example, Given s = “eceba”,
T is "ece" which its length is 3.
```java
/*
the idea is use a map to track the count of the letters and the number of distinct letters
1. only increment the distinctCount when seen a new word
2. increment the count of letters in the map every time
3. while the distinctCount > 2, remove the letter count from left,
decrement the distinctCount when any letter count became 0
4. keep updating the longest
*/
class Solution {
    public int lengthOfLongestSubstringTwoDistinct(String s) {
        if (s == null || s.length() == 0) {
            return 0;
        }
        if (s.length() < 3) {
            return s.length();
        }
        int[] map = new int[256];
        int distinctCount = 0;
        int longest = 0;
        for (int left = 0, right = 0; right < s.length(); ++right) {
            if (++map[s.charAt(right)] == 1) {
                ++distinctCount;
            }
            while (distinctCount > 2) {
                if (--map[s.charAt(left++)] == 0) {
                    --distinctCount;
                }
            }
            longest = Math.max(longest, right - left + 1);
        }
        return longest;
    }
}
```
160. Intersection of Two Linked Lists

Write a program to find the node at which the intersection of two singly linked lists begins.


For example, the following two linked lists:

A:          a1 → a2
                   ↘
                     c1 → c2 → c3
                   ↗            
B:     b1 → b2 → b3
begin to intersect at node c1.


Notes:

If the two linked lists have no intersection at all, return null.
The linked lists must retain their original structure after the function returns.
You may assume there are no cycles anywhere in the entire linked structure.
Your code should preferably run in O(n) time and use only O(1) memory.
```java
/*
idea is traversal list a and b to the end and count nodes of both list, 
if they end at the same node, means they have intersection, otherwise, they do not have
then, let the more nodes list go diff steps first, then the first time they meet, is the intersection.
 */
public class Solution {
    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {
        if (headA == null || headB == null) {
            return null;
        }
        ListNode tailA = headA;
        ListNode tailB = headB;
        int countA = 1;
        int countB = 1;
        while (tailA.next != null) {
            tailA = tailA.next;
            ++countA;
        }
        while (tailB.next != null) {
            tailB = tailB.next;
            ++countB;
        }
        if (tailA != tailB) {
            return null;
        }
        tailA = headA;
        tailB = headB;
        while (countA > countB) {
            --countA;
            tailA = tailA.next;
        }
        while (countB > countA) {
            --countB;
            tailB = tailB.next;
        }
        while (tailA != tailB) {
            tailA = tailA.next;
            tailB = tailB.next;
        }
        return tailA;
    }
}
```
161. One Edit Distance
Given two strings S and T, determine if they are both one edit distance apart.

```java
/*
0. the length diff is 1
the idea is treat the problem in 3 cases when we found an unmatch char 
1. when lenS > lenT, the s.substring(i + 1) should equals to t.substring(i)
2. same logic for lenT > lenS
3. when lenS == lenT, the s.substring(i + 1) should equals to t.substring(i + 1), or i is the last index
4. if all chars are matched, the lenS and lenT must diff
*/
class Solution {
    public boolean isOneEditDistance(String s, String t) {
        if (s == null || t == null) {
            return false;
        }
        int lenS = s.length();
        int lenT = t.length();
        if (lenS - lenT > 1 || lenT - lenS > 1) {
            return false;
        }
        for (int i = 0; i < lenS && i < lenT; ++i) {
            if (s.charAt(i) == t.charAt(i)) {
                continue;
            }
            if (lenS > lenT) {
                return s.substring(i + 1).equals(t.substring(i));
            } else if (lenT > lenS) {
                return s.substring(i).equals(t.substring(i + 1));
            } else {
                return i == lenS - 1 || s.substring(i + 1).equals(t.substring(i + 1));
            }
        }
        return lenS != lenT;
    }
}
```
162. Find Peak Element

A peak element is an element that is greater than its neighbors.

Given an input array where num[i] ≠ num[i+1], find a peak element and return its index.

The array may contain multiple peaks, in that case return the index to any one of the peaks is fine.

You may imagine that num[-1] = num[n] = -∞.

For example, in array [1, 2, 3, 1], 3 is a peak element and your function should return the index number 2.
```java
/*
the idea is use binary search, if a < mid > b, return mid,
if a < mid < b < +INF, then a peek must in right, otherwise, it one must in left
*/
class Solution {
    public int findPeakElement(int[] nums) {
        if (nums == null || nums.length == 0) {
            return -1;
        }
        if (nums.length == 1) {
            return 0;
        }
        int left = 0;
        int right = nums.length - 1;
        while (left + 1 < right) {
            int mid = (right - left) / 2 + left;
            if (nums[mid] > nums[mid - 1] && nums[mid] > nums[mid + 1]) {
                return mid;
            } else if (nums[mid] > nums[mid - 1]) {
                left = mid;
            } else {
                right = mid;
            }
        }
        return nums[left] > nums[right] ? left : right;
    }
}
```
163. Missing Ranges

Given a sorted integer array where the range of elements are in the inclusive range [lower, upper], return its missing ranges.

For example, given [0, 1, 3, 50, 75], lower = 0 and upper = 99, return ["2", "4->49", "51->74", "76->99"].
```java
/* very important point, 
1. skip dupulicate element in the array first
2. the elements may contains int_max or int_min
the idea is treat the problem in 4 cases
1. the array is null or empty
2. normal missing range
3. the last element in the array is less than the upper range
*/
class Solution {
    public List<String> findMissingRanges(int[] nums, int lower, int upper) {
        List<String> res = new ArrayList<>();
        if (nums == null || nums.length == 0) {
            addToResult(res, nums, lower, upper);
            return res;
        }
        for (int i = 0; i < nums.length; ++i) {
            int num = nums[i];
            if(i + 1 < nums.length && num == nums[i + 1]){
                continue;
            }
            if (num == lower) {
                ++lower;
            } else {
                addToResult(res, nums, lower, num - 1);
                lower = num + 1;
            }
        }
        if (nums[nums.length - 1] < upper) {
            addToResult(res, nums, nums[nums.length - 1] + 1, upper);
        }
        return res;
    }
    public void addToResult(List<String> res, int[] nums, int lower, int upper) {
        if (lower == upper) {
            res.add(String.valueOf(lower));
        } else {
            res.add(lower + "->" + upper);
        }
    }
}
```
164. Maximum Gap

Given an unsorted array, find the maximum difference between the successive elements in its sorted form.

Try to solve it in linear time/space.

Return 0 if the array contains less than 2 elements.

You may assume all elements in the array are non-negative integers and fit in the 32-bit signed integer range.
```java
/*
the idea is put n numbers into n buckets, there will be two cases
1. if each bucket perfectly been filled one number, then the array is sorted, we can simply find the gap
2. otherwise, some bucket may contains more than one numbers, then there must be one or more empty bucket
if we use min and max to define the edge of the buckets, then if there is empty bucket(s),
then the max of the left bucket and min of the right bucket will be the potential answer

**important**
question is what will be the size for each bucket? (int)Math.ceil((double)(max - min) / (len - 1));
because, between min and max, there are len - 1 gaps, 
as ceil will round up, means the gap will cover all the numbers in the gap,
when find the index for the bucket, we must use (nums[i] - min) / gap, subtract the min to make it 0based
after finish fill all buckets, we can simply use the curMin subtract the preMax to calculate and update the maxGap.
*/
class Solution {
    public int maximumGap(int[] nums) {
        if (nums == null || nums.length < 2) {
            return 0;
        }
        int len = nums.length;
        int min = nums[0];
        int max = nums[0];
        int[] minBucket = new int[len];
        int[] maxBucket = new int[len];
        for (int i = 0; i < len; ++i) {
            min = Math.min(min, nums[i]);
            max = Math.max(max, nums[i]);
            minBucket[i] = Integer.MAX_VALUE;
            maxBucket[i] = Integer.MIN_VALUE;
        }
        if (min == max) {
            return 0;
        }
        int gap = (int)Math.ceil((double)(max - min) / (len - 1));
        for (int i = 0; i < len; ++i) {
            int index = (nums[i] - min) / gap;
            minBucket[index] = Math.min(nums[i], minBucket[index]);
            maxBucket[index] = Math.max(nums[i], maxBucket[index]);
        }
        int i = 0;
        int preMax = 0;
        for (; i < len; ++i) {
            if (maxBucket[i] != Integer.MIN_VALUE) {
                preMax = maxBucket[i];
                break;
            }
        }
        int curMin = 0;
        int maxGap = 0;
        for (i = i + 1; i < len; ++i) {
            if (minBucket[i] == Integer.MAX_VALUE) {
                continue;
            }
            curMin = minBucket[i];
            maxGap = Math.max(maxGap, curMin - preMax);
            preMax = maxBucket[i];
        }
        return maxGap;
    }
}
```
165. Compare Version Numbers

Compare two version numbers version1 and version2.
If version1 > version2 return 1, if version1 < version2 return -1, otherwise return 0.

You may assume that the version strings are non-empty and contain only digits and the . character.
The . character does not represent a decimal point and is used to separate number sequences.
For instance, 2.5 is not "two and a half" or "half way to version three", it is the fifth second-level revision of the second first-level revision.

Here is an example of version numbers ordering:

0.1 < 1.1 < 1.2 < 13.37
```java
//need to be careful some special cases
//1 and 1.0  //1 and 1.0.1 
//another thing is when you split string by . * |, you must add "\\." because those are reserverd
class Solution {
    public int compareVersion(String version1, String version2) {
        if (version1.equals(version2)) {
            return 0;
        }
        String[] v1 = version1.split("\\.");
        String[] v2 = version2.split("\\.");
        for (int i = 0; i < v1.length || i < v2.length; ++i) {
            int segment1 = i < v1.length && v1[i].length() > 0 ? Integer.parseInt(v1[i]) : 0;
            int segment2 = i < v2.length && v2[i].length() > 0 ? Integer.parseInt(v2[i]) : 0;
            if (segment1 > segment2) {
                return 1;
            }
            if (segment1 < segment2) {
                return -1;
            }
        }
        return 0;
    }
}
```
166. Fraction to Recurring Decimal

Given two integers representing the numerator and denominator of a fraction, return the fraction in string format.

If the fractional part is repeating, enclose the repeating part in parentheses.

For example,

Given numerator = 1, denominator = 2, return "0.5".
Given numerator = 2, denominator = 1, return "2".
Given numerator = 2, denominator = 3, return "0.(6)".
```java
/*
idea is divide the problem into four parts, most diffcuilt part is step 3 and 4
1. if the final result is nagative
2. integer part of the quotient
3. non - repeat decimal part of the quotient
4. repeat decimal part of the quotient

the idea is use a map, k: reminder, v : current index, 
when found a repeat reminder, insert "(" before the index of the reminder first time been seen
then append ")" and return
**important** Math.abs(MIN_VALUE) will overflow
*/
class Solution {
    public String fractionToDecimal(int numerator, int denominator) {
        if (numerator == 0 || denominator == 0) {
            return "0";
        }
        StringBuilder res = new StringBuilder();
        if ((numerator < 0) ^ (denominator < 0)) {
            res.append("-");
        }
        // **important** Math.abs(MIN_VALUE) will overflow
        long n = Math.abs((long)numerator);
        long d = Math.abs((long)denominator);
        res.append(n / d);
        long reminder = n % d;
        if (reminder == 0) {
            return res.toString();
        } else {
            res.append(".");
        }
        //k: reminder, v : current index
        Map<Long, Integer> map = new HashMap<>();
        map.put(reminder, res.length());
        while (reminder != 0) {
            reminder *= 10;
            res.append(reminder / d); 
            reminder %= d; 
            if (map.containsKey(reminder)) {
                res.insert(map.get(reminder), "(");
                res.append(")");
                return res.toString();
            } else {
                map.put(reminder, res.length());
            }
        }
        return res.toString();
    }
}
```
167. Two Sum II - Input array is sorted

Given an array of integers that is already sorted in ascending order, find two numbers such that they add up to a specific target number.

The function twoSum should return indices of the two numbers such that they add up to the target, where index1 must be less than index2. Please note that your returned answers (both index1 and index2) are not zero-based.

You may assume that each input would have exactly one solution and you may not use the same element twice.

Input: numbers={2, 7, 11, 15}, target=9
Output: index1=1, index2=2
```java
class Solution {
    public int[] twoSum(int[] numbers, int target) {
        //range issue, edge case, null, length, target < min + min, target > max + max    
        for (int left = 0, right = numbers.length - 1; left < right; ) {
            if (numbers[left] + numbers[right] == target) {
                return new int[]{left + 1, right + 1};
            } else if (numbers[left] + numbers[right] < target) {
                ++left;
            } else {
                --right;
            }
        }
        return new int[]{0, 0};
    }
}
```
168. Excel Sheet Column Title

Given a positive integer, return its corresponding column title as appear in an Excel sheet.

For example:

    1 -> A
    2 -> B
    3 -> C
    ...
    26 -> Z
    27 -> AA
    28 -> AB 
```java
/*
idea is every time, get the n % 26 reminder, insert the mapping letter,
**important ** only thing is if the reminder is 0, we should append 'Z', then subtract 26
then divide by 26
for example 52, is AZ
*/
class Solution {
    public String convertToTitle(int n) {
        if (n < 1) {
            return "";
        }
        StringBuilder res = new StringBuilder();
        while (n > 0) {
            int reminder = n % 26;
            if (reminder == 0) {
                res.insert(0, 'Z');
                n -= 26;
            } else {
                res.insert(0, (char)(reminder + 'A' - 1));
            }
            n /= 26;
        }
        return res.toString();
    }
}
```
169. Majority Element

Given an array of size n, find the majority element. The majority element is the element that appears more than ⌊ n/2 ⌋ times.

You may assume that the array is non-empty and the majority element always exist in the array.
```java
/*
three apporach
1. sort, and return the nums[nums.length/2]  ----nlogn
2. use hashmap value - count  ----time n, space n
3. count,  for example, nums {1,2,1,3,1}
if the count is greater than 0, we continue assume the current number is the majority, otherwise, we just change it,
eventually, the number with positive count will be the majority,
*/
class Solution {
    public int majorityElement(int[] nums) {
        int majorityNumber = nums[0];
        int count = 0;
        int half = nums.length / 2;
        for (int n: nums) {
            if (n == majorityNumber) {
                if (++count > half) {
                    return n;
                }
            } else {
                if (--count == 0) {
                    majorityNumber = n;
                    ++count;
                }
            }
        }
        return majorityNumber;
    }
}
```
170. Two Sum III - Data structure design

Design and implement a TwoSum class. It should support the following operations: add and find.

add - Add the number to an internal data structure.
find - Find if there exists any pair of numbers which sum is equal to the value.

For example,
add(1); add(3); add(5);
find(4) -> true
find(7) -> false
```java
/*
idea is use a map to keep track the number's count
then when iterate the map, we know we found the two sum when:
1. when a == b and the count of a is greater than 1, we find
2. when a != b and the map contains b
optimaztion: we can keep track the minVal and maxVal, 
if the value is less than minVal*2 or greater than maxVal*2, there is no way we can find it
*/
class TwoSum {
    int minVal = Integer.MAX_VALUE;
    int maxVal = Integer.MIN_VALUE;
    Map<Integer, Integer> map = new HashMap<>();

    /** Add the number to an internal data structure.. */
    public void add(int number) {
        map.put(number, map.getOrDefault(number, 0) + 1);
        minVal = Math.min(minVal, number);
        maxVal = Math.max(maxVal, number);
    }
    
    /** Find if there exists any pair of numbers which sum is equal to the value. */
    public boolean find(int value) {
        if (map.isEmpty() || value < minVal * 2 || value > maxVal * 2) {
            return false;
        }
        for (int i: map.keySet()) {
            int j = value - i;
            if ((i == j && map.get(i) > 1) || (i != j && map.containsKey(j))) {
                return true;
            }
        }
        return false;
    }
}
```
171. Excel Sheet Column Number

Related to question Excel Sheet Column Title

Given a column title as appear in an Excel sheet, return its corresponding column number.

For example:

    A -> 1
    B -> 2
    C -> 3
    ...
    Z -> 26
    AA -> 27
    AB -> 28 

```java
/*
idea is every time, use last result multiply 26 then add the current letter's value 
for example 27, A * 26 + A, 52 is a * 26 + Z
*/
class Solution {
    public int titleToNumber(String s) {
        if (s == null || s.length() == 0) {
            return 0;
        }
        int res = 0;
        for (int i = 0; i < s.length(); ++i) {
            res *= 26;
            res += s.charAt(i) - 'A' + 1;
        }
        return res;
    }
}
```
172. Factorial Trailing Zeroes

Given an integer n, return the number of trailing zeroes in n!.

Note: Your solution should be in logarithmic time complexity.
```java
/*
the idea is all the 0 comes from 2 time 5, then the question will be find how many pairs of 2 and 5,
for example 5! 1 * 2 * 3 * 4 * 5, there is one 2 and one 5, also, 4 is 2 time 2, that means, for each 5, 
there is always at least a 2, then the question will be find how many 5s
**important**
if we simple do a n / 5, we will miss some implicit 5s, like 25!, 25/5 is 5, but 25 itself is 5 * 5, so it will be six 5s.
*/
class Solution {
    public int trailingZeroes(int n) {
        int count5 = 0;
        while (n >= 5) {
            count5 += n / 5;
            n /= 5;
        }
        return count5;
    }
}
```
173. Binary Search Tree Iterator

Implement an iterator over a binary search tree (BST). Your iterator will be initialized with the root node of a BST.

Calling next() will return the next smallest number in the BST.

Note: next() and hasNext() should run in average O(1) time and uses O(h) memory, where h is the height of the tree.
```java
/*
idea is use a stack to implement the iterative version of inorder traversal
use a global TreeNode curr, we can know the current position
if there is a left node, then the most left must be the smallest,
if the most left node is a leaf, then the curr will be null, but the stack may still have the it parent
then after another calling next(), as the curr is null, we will pop the parent of the last smallest
 */
public class BSTIterator {
    Deque<TreeNode> stack;
    TreeNode curr;
    public BSTIterator(TreeNode root) {
        stack = new ArrayDeque<>();
        curr = root;
    }

    /** @return whether we have a next smallest number */
    public boolean hasNext() {
        return curr != null || !stack.isEmpty();
    }

    /** @return the next smallest number */
    public int next() {
        while (curr != null) {
            stack.push(curr);
            curr = curr.left;
        }
        curr = stack.pop();
        int smallest = curr.val;
        curr = curr.right;
        return smallest;
    }
}
/**
 * Your BSTIterator will be called like this:
 * BSTIterator i = new BSTIterator(root);
 * while (i.hasNext()) v[f()] = i.next();
 */
```
174. Dungeon Game
The demons had captured the princess (P) and imprisoned her in the bottom-right corner of a dungeon. The dungeon consists of M x N rooms laid out in a 2D grid. Our valiant knight (K) was initially positioned in the top-left room and must fight his way through the dungeon to rescue the princess.

The knight has an initial health point represented by a positive integer. If at any point his health point drops to 0 or below, he dies immediately.

Some of the rooms are guarded by demons, so the knight loses health (negative integers) upon entering these rooms; other rooms are either empty (0's) or contain magic orbs that increase the knight's health (positive integers).

In order to reach the princess as quickly as possible, the knight decides to move only rightward or downward in each step.


Write a function to determine the knight's minimum initial health so that he is able to rescue the princess.

For example, given the dungeon below, the initial health of the knight must be at least 7 if he follows the optimal path RIGHT-> RIGHT -> DOWN -> DOWN.

-2 (K)	-3	3
-5	-10	1
10	30	-5 (P)

Notes:

The knight's health has no upper bound.
Any room can contain threats or power-ups, even the first room the knight enters and the bottom-right room where the princess is imprisoned.
```java
/*
idea is use dp, explore from bottom right to top left,
because, the bottom right is known, and we need at least 1 after enter the next room
**optimization** can use only O(N) space 
*/
//O(mn) time O(n) space
class Solution {
    public int calculateMinimumHP(int[][] dungeon) {
        int row = dungeon.length;
        int col = dungeon[0].length;
        int[] mins = new int[col];
        for (int i = row - 1; i >= 0; --i) {
            for (int j = col - 1; j >= 0; --j) {
                if (i == row - 1 && j == col - 1) {
                    mins[j] = dungeon[i][j] < 0 ? 1 - dungeon[i][j] : 1;
                } else if (i == row - 1) {
                    mins[j] = Math.max(1, mins[j + 1] - dungeon[i][j]);
                } else if (j == col - 1) {
                    mins[j] = Math.max(1, mins[j] - dungeon[i][j]);
                } else {
                    int smaller = Math.min(mins[j], mins[j + 1]);
                    mins[j] = Math.max(1, smaller - dungeon[i][j]);
                }
            }
        }
        return mins[0];
    }
}
//O(mn) time O(mn) space
class Solution {
    public int calculateMinimumHP(int[][] dungeon) {
        int row = dungeon.length;
        int col = dungeon[0].length;
        int[][] mins = new int[row][col];
        for (int i = row - 1; i >= 0; --i) {
            for (int j = col - 1; j >= 0; --j) {
                if (i == row - 1 && j == col - 1) {
                    mins[i][j] = dungeon[i][j] < 0 ? 1 - dungeon[i][j] : 1;
                } else if (i == row - 1) {
                    mins[i][j] = Math.max(1, mins[i][j + 1] - dungeon[i][j]);
                } else if (j == col - 1) {
                    mins[i][j] = Math.max(1, mins[i + 1][j] - dungeon[i][j]);
                } else {
                    int smaller = Math.min(mins[i + 1][j], mins[i][j + 1]);
                    mins[i][j] = Math.max(1, smaller - dungeon[i][j]);
                }
            }
        }
        return mins[0][0];    
    }
}
```
179. Largest Number

Given a list of non negative integers, arrange them such that they form the largest number.

For example, given [3, 30, 34, 5, 9], the largest formed number is 9534330.

Note: The result may be very large, so you need to return a string instead of an integer.
```java
/*
idea is implement customized arrays sort, lexicographical descending order by compare a + b and b + a
return ab.compareTo(ba) will be ascending order, and ba.compareTo(ab) will be descending order
special case if all the number in the array is 0
*/
class Solution {
    public String largestNumber(int[] nums) {
        if (nums == null || nums.length == 0) {
            return "";
        }
        String[] str = new String[nums.length];
        for (int i = 0; i < nums.length; ++i) {
            str[i] = String.valueOf(nums[i]);
        }
        Arrays.sort(str, new Comparator<String>() {
            @Override
            public int compare(String a, String b) {
                String ab = a + b;
                String ba = b + a;
                return ba.compareTo(ab);
            }
        });
        if (str[0].equals("0")) {
            return "0";
        }
        StringBuilder res = new StringBuilder();
        for (String s: str) {
            res.append(s);
        }
        return res.toString();
    }
}
```
187. Repeated DNA Sequences

All DNA is composed of a series of nucleotides abbreviated as A, C, G, and T, for example: "ACGAATTCCG". When studying DNA, it is sometimes useful to identify repeated sequences within the DNA.

Write a function to find all the 10-letter-long sequences (substrings) that occur more than once in a DNA molecule.

For example,

Given s = "AAAAACCCCCAAAAACCCCCCAAAAAGGGTTT",

Return:
["AAAAACCCCC", "CCCCCAAAAA"].
```java
/*first idea is use hashmap then use average O(n) time to scan the whole string
BUT, it can be optimized by use bit minipulation. as there are only 4 options, 
then we can use 2 bits to express the 4 options(00,01,10,11), as there is only 10 letters long for each sequences
mean 2 * 10 bit (less than a int size)is enough for a sequence.
use a 2 * 10 size of boolean array to track if the current sequences is repeat, use a set to add result
*/
class Solution {
    public List<String> findRepeatedDnaSequences(String s) {
        if (s == null || s.length() < 10) {
            return new ArrayList<>();
        }
        Set<String> repeatDna = new HashSet<>();
        boolean[] map = new boolean[(int)Math.pow(2, 20)];
        for (int i = 0; i <= s.length() - 10; ++i) {
            String curr = s.substring(i, i + 10);
            int code = encode(curr);
            if (map[code]) {
                repeatDna.add(curr);
            } else {
                map[code] = true;
            }
        }
        return new ArrayList<>(repeatDna);
    }
    private int encode(String s) {
        int code = 0;
        for (int i = 0; i < s.length(); ++i) {
            char c = s.charAt(i);
            code = code << 2;
            if (c == 'A') { code += 0; }
            if (c == 'C') { code += 1; }
            if (c == 'G') { code += 2; }
            if (c == 'T') { code += 3; }
        }
        return code;
    }
    //not for this question
    private String decode(int num) {
        StringBuilder sb = new StringBuilder();
        for(int i = 0; i < 10; i++){
            if (num % 4 == 0) { sb.append('A'); }
            if (num % 4 == 1) { sb.append('C'); }
            if (num % 4 == 2) { sb.append('G'); }
            if (num % 4 == 3) { sb.append('T'); }
            num = num >> 2;
        }
        return sb.reverse().toString();
    }
}
```
188. Best Time to Buy and Sell Stock IV

Say you have an array for which the ith element is the price of a given stock on day i.

Design an algorithm to find the maximum profit. You may complete at most k transactions.

Note:
You may not engage in multiple transactions at the same time (ie, you must sell the stock before you buy again).
```java
/* time O(n * k) space O(k)
思路就是对于每个价格，都更新2k个状态，第k次卖和买 到第一个卖和买，
每一次卖出的价格就等于 上一次卖出的最大值或者上次买完加上卖出当前股票 二者的最大值
每一次买入的价格就等于 上一次买入的最大值或者上次卖完减去买入当前股票 二者的最大者
不停地对每个价格都更新这 2k个状态，最后的最大值就是第k次卖出的最大值
0. 如果k大于股票数量的一半，相当于可以交易“无限次”
1. 新建2个数组，来cache 买入和卖出的 2k的状态，并初始买入价格全是 MIN_VALUE
*/
class Solution {
    public int maxProfit(int k, int[] prices) {
        if (prices == null || prices.length < 2 || k < 1) {
            return 0;
        }
        if (k >= prices.length / 2) {
            int sum = 0;
            int buy = 0;
            for (int sell = 1; sell < prices.length; ++sell) {
                if (prices[sell] < prices[sell - 1]) {
                    sum += prices[sell - 1] - prices[buy];
                    buy = sell;
                }
            }
            return sum + prices[prices.length - 1] - prices[buy];
        }
        int[] hold = new int[k + 1];
        int[] sell = new int[k + 1];
        Arrays.fill(hold, Integer.MIN_VALUE);
        for (int price : prices) {
            for (int i = k; i > 0; --i) {
                sell[i] = Math.max(sell[i], hold[i] + price);
                hold[i] = Math.max(hold[i], sell[i - 1] - price);
            }
        }
        return sell[k];
    }
}
```
189. Rotate Array

Rotate an array of n elements to the right by k steps.

For example, with n = 7 and k = 3, the array [1,2,3,4,5,6,7] is rotated to [5,6,7,1,2,3,4].

Note:
Try to come up as many solutions as you can, there are at least 3 different ways to solve this problem.

[show hint]

Hint:
Could you do it in-place with O(1) extra space?
```java
//O(1)space. reverse the whole array, then reverse the first k elements, then reverse the rest
class Solution {
    public void rotate(int[] nums, int k) {
        //edge case
        if(nums == null || nums.length < 2 || k % nums.length == 0){
            return;
        } 
        int n = nums.length;    
        k = k % n; 
        reverse(nums, 0, n - 1);
        reverse(nums, 0, k - 1);
        reverse(nums, k, n - 1);
    }
    public void reverse(int[] nums, int i, int j) {
        for (; i < j; ++i, --j) {
            int tem = nums[i];
            nums[i] = nums[j];
            nums[j] = tem;
        }
    }
}
//need to ask the range of the n, if the n is over half of the max_int, we need use long instead of int
//the idea is make a 2 time length new array, then copy back to the original array from index n - k
// class Solution {
//     public void rotate(int[] nums, int k) {
//         //edge case
//         if(nums == null || nums.length < 2 || k % nums.length == 0){
//             return;
//         } 
//         int n = nums.length;    
//         k = k % n;        
//         int[] num = new int[n + n];
//         System.arraycopy(nums, 0, num, 0, n);
//         System.arraycopy(nums, 0, num, n, n);
//         System.arraycopy(num, n - k, nums, 0, n);        
//     }
// }
```
190. Reverse Bits

Reverse bits of a given 32 bits unsigned integer.

For example, given input 43261596 (represented in binary as 00000010100101000001111010011100), return 964176192 (represented in binary as 00111001011110000010100101000000).

Follow up:
If this function is called many times, how would you optimize it?
```java
/*
idea is keep add the most right binary to a new number, then left shift the new number
0. important, we have to loop 31 times 
1. left shift the result, give the space for the incoming digit
2. if the most right in n is 1, add one to the result, otherwise, leave it as 0
3. right shift the n, ready for the next most right
*/
public class Solution {
    // you need treat n as an unsigned value
    public int reverseBits(int n) {
        int res = 0;
        for (int i = 0; i < 32; ++i) {
            res = res << 1;
            if ((n & 1) == 1) {
                res += 1;
            }
            n = n >>> 1;
        }
        return res;
    }
}
```
191. Number of 1 Bits

Write a function that takes an unsigned integer and returns the number of ’1' bits it has (also known as the Hamming weight).

For example, the 32-bit integer ’11' has binary representation 00000000000000000000000000001011, so the function should return 3.
```java
public class Solution {
    // you need to treat n as an unsigned value
    public int hammingWeight(int n) {
        int count = 0;
        for (int i = 0; i < 32; ++i) {
            count += (n & 1);
            n = n >>> 1;
        }
        return count;
    }
}
```
198. House Robber

You are a professional robber planning to rob houses along a street. Each house has a certain amount of money stashed, the only constraint stopping you from robbing each of them is that adjacent houses have security system connected and it will automatically contact the police if two adjacent houses were broken into on the same night.

Given a list of non-negative integers representing the amount of money of each house, determine the maximum amount of money you can rob tonight without alerting the police.
```java
/* this dp will cache the one of the best results (1/2)
the idea is if we choose to rob the first house, then, next house will be either house 3 or 4,
then if the house 2 is a very larger number, we may miss the right answer,
so, we have to use two route, start from 1 and 2,
then I found out, for any single point, we must come from either one house in the middle or two,
base on those information, we can use DP to solve this problem

**more clear approach** this dp will cache the best result
for each house, we have two choices, rob it, or do not rob it
then the current max will be, max of the following two
1. rob it, then we must not rob the previous one, so will be nums[i] + dp[i -2]
2. not rob it, then we just carry the previous max result which is dp[i - 1];
**optimazation** can be optimized to O(1)space
1. rob it, then we must not rob the previous one, so will be nums[i] + notrob
2. not rob it, then we just carry the previous max result which is rob;
*/
class Solution {
    public int rob(int[] nums) {
        if (nums == null || nums.length == 0) {
            return 0;
        }
        if (nums.length == 1) {
            return nums[0];
        }
        int rob = 0;
        int notrob = 0;
        for (int n: nums) {
            int tem = notrob;
            notrob = Math.max(rob, notrob);
            rob = n + tem;
        }
        return Math.max(rob, notrob);
    }
}
class Solution {
    public int rob(int[] nums) {
        if (nums == null || nums.length == 0) {
            return 0;
        }
        if (nums.length == 1) {
            return nums[0];
        }
        int[] max = new int[nums.length];
        for (int i = 0; i < nums.length; ++i) {
            if (i < 2) {
                max[i] = nums[i];
            }
            if (i == 2) {
                max[i] = nums[i] + nums[i - 2];
            }
            if (i > 2) {
                max[i] = nums[i] + Math.max(max[i - 2], max[i - 3]);
            }
        }
        return Math.max(max[nums.length - 1], max[nums.length - 2]);
    }
}
```
199. Binary Tree Right Side View

Given a binary tree, imagine yourself standing on the right side of it, return the values of the nodes you can see ordered from top to bottom.

For example:
Given the following binary tree,
   1            <---
 /   \
2     3         <---
 \     \
  5     4       <---
You should return [1, 3, 4].

```java
/*
itrative: idea is level traversal, for each level, we add the last node to the list
recrison: implment a custmized pre order, but start from the right side,
then add the node to the list only when the size of list less than the current level
 */
//itratively
class Solution {
    public List<Integer> rightSideView(TreeNode root) {
        List<Integer> res = new ArrayList<>();
        rightSideViewHelper(res, root, 1);
        return res;
    }
    public void rightSideViewHelper(List<Integer> res, TreeNode head, int level) {
        if (head == null) {
            return;
        }
        if (res.size() < level) {
            res.add(head.val);
        }
        rightSideViewHelper(res, head.right, level + 1);
        rightSideViewHelper(res, head.left, level + 1);
    }
}

// class Solution {
//     public List<Integer> rightSideView(TreeNode root) {
//         List<Integer> res = new LinkedList<Integer>();
//         //edge case
//         if(root == null){
//             return res;
//         }
//         Queue<TreeNode> que = new LinkedList<>();
//         que.offer(root);
        
//         while(!que.isEmpty()){
//             int nodePerLevel = que.size();
//             while(--nodePerLevel >= 0){
//                 TreeNode curr = que.poll();
//                 if(nodePerLevel == 0){
//                     res.add(curr.val);
//                 }
//                 if(curr.left != null){
//                     que.offer(curr.left);
//                 }
//                 if(curr.right != null){
//                     que.offer(curr.right);
//                 }
//             }
//         }
//         return res;
//     }
// }
```
200. Number of Islands

Given a 2d grid map of '1's (land) and '0's (water), count the number of islands. An island is surrounded by water and is formed by connecting adjacent lands horizontally or vertically. You may assume all four edges of the grid are all surrounded by water.

Example 2:

11000
11000
00100
00011
Answer: 3
```java
class Solution {
    /**  time O(n^2) 空间的话2种方案，一个是O(1)但改原数组，一个是O(n^2)
     * 思路就是 从每个1开始向4个方向dfs，dfs过程中碰见任何1，都标记成x，这样每个岛就只会记录一次1，
     * 之后再把'x'变回来就行， 或者就用一个 n^2的布尔数组标记visited
     * */
    public int numIslands(char[][] grid) {
        if (grid == null || grid.length == 0 || grid[0] == null || grid[0].length == 0) {
            return 0;
        }
        int row = grid.length;
        int col = grid[0].length;
        int count = 0;
        for (int i = 0; i < row; ++i) {
            for (int j = 0; j < col; ++j) {
                if (grid[i][j] == '1') {
                    explore(grid, i, j);
                    ++count;
                }
                if (grid[i][j] == 'x') {
                    grid[i][j] = '1';
                }
            }
        }
        return count;
    }
    private void explore(char[][] grid, int row, int col) {
        if (row < 0 || row >= grid.length || col < 0 || col >= grid[0].length || grid[row][col] != '1') {
            return;
        }
        grid[row][col] = 'x';
        explore(grid, row + 1, col);
        explore(grid, row - 1, col);
        explore(grid, row, col+ 1);
        explore(grid, row, col - 1);
    }
}
```
